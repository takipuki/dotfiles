<!DOCTYPE html>
<html>
<head>
  <title>Linear C++</title>
  <link rel="stylesheet" type="text/css" href="clean.css">
</head>
<body>
<h1 id="readme.md">README.md</h1>
<h2 id="linear-c">Linear C++</h2>
<p>A C++ tutorial that can (hopefully?) be followed without jumping from
chapter to chapter at every step.</p>
<h3 id="downloads">Downloads:</h3>
<ul>
<li><a
href="https://github.com/jesyspa/linear-cpp/archive/master.zip">No
project files</a></li>
<li><a
href="https://github.com/jesyspa/linear-cpp/archive/with_codeblocks_project_files.zip">Code::Blocks
project files</a></li>
</ul>
<h3 id="building">Building</h3>
<p>Via a bash shell, compiling all chapters:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> Chapter<span class="pp">*</span><span class="kw">;</span> <span class="cf">do</span> <span class="ex">g++</span> <span class="at">-std</span><span class="op">=</span>c++11 <span class="at">-o</span> <span class="st">&quot;</span><span class="va">$a</span><span class="st">/out&quot;</span> <span class="st">&quot;</span><span class="va">$a</span><span class="st">&quot;</span>/<span class="pp">*</span>.cpp<span class="kw">;</span> <span class="cf">done</span></span></code></pre></div>
<p>On OSX: - You must install XCode and the Command Line Tools package.
As of 9/04/2013, Mac OS X doesn’t ship with a C++11 compiler. - Then use
clang to build:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> Chapter<span class="pp">*</span><span class="kw">;</span> <span class="cf">do</span> <span class="fu">clang</span>++ <span class="at">--std</span><span class="op">=</span>c++11 <span class="at">--stdlib</span><span class="op">=</span>libc++ <span class="st">&quot;</span><span class="va">$a</span><span class="st">&quot;</span>/<span class="pp">*</span>.cpp <span class="at">-o</span> <span class="st">&quot;</span><span class="va">$a</span><span class="st">&quot;</span>/out<span class="kw">;</span> <span class="cf">done</span></span></code></pre></div>
<p>Also, when compiling your own files on either of those two platforms,
I recommend you add <code>-Wall</code> and <code>-Wextra</code> to your
flags. Clang users may also want to add
<code>-fsanitize=undefined</code>.</p>
<h3 id="markdown-and-epub">Markdown and EPUB</h3>
<p>Thanks to <a href="https://github.com/Gullumluvl"><span
class="citation" data-cites="Gullumluvl">@Gullumluvl</span></a> it’s
possible to export these chapters as Markdown or epub files!</p>
<p>To do so, just run</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./cpp_2_markdown.py</span> Chapter\ NN<span class="pp">*</span></span></code></pre></div>
<p>where <code>NN</code> is the number of the chapter.</p>
<p>You can use</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./cpp_2_markdown.py</span> .</span></code></pre></div>
<p>to build the whole book.</p>
<p>For building an epub, make sure you have <code>pandoc</code> and
run</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pandoc</span> <span class="at">-M</span> author=jesyspa <span class="dt">\</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">--standalone</span> <span class="dt">\</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">-V</span> <span class="st">&#39;header-includes=&quot;&lt;style&gt;pre &gt; code.sourceCode {white-space: pre-wrap !important;}&lt;/style&gt;&quot;&#39;</span> <span class="dt">\</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">--toc</span> <span class="at">--toc-depth</span><span class="op">=</span>1 <span class="dt">\</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">-o</span> linear-cpp.epub <span class="dt">\</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  ebook.md</span></code></pre></div>
<p>The <code>header-includes</code> argument is needed to wrap long code
lines.</p>
<h3 id="future-plans">Future plans</h3>
<p>This project is discontinued. I don’t plan to update it for new C++
standards or add any new language features.</p>
<p>Outline of what’s <del>coming</del> missing: - Practical Examples -
Variants, Optional - Most of inheritance - Scope - Storage Duration -
Undefined Behaviour - File IO - Libraries: Boost, Abseil… -
Metaprogramming - C++14 and up - The preprocessor - Most C features</p>
<p>So while I’m glad people have found it useful, please <em>don’t</em>
rely on this by itself to learn C++! It really only scratches the
surface, and you’ll do yourself a service if you get a <a
href="https://stackoverflow.com/q/388242/559931">good book</a>.</p>
<h1 id="chapter-00---foreword">Chapter 00 - Foreword</h1>
<h2 id="main.cpp">main.cpp</h2>
<p>Hi! This is a multi-line comment. I’m terrible at doing any kind of
web work, but I really wanted to make a less bad resource for learning
C++ available online, so I decided to do what I usually do with C++:
make a Github repository and write C++ programs. Just reading the
programs would probably be too confusing to learn the language, so I
added lots of comments to explain what’s going on.</p>
<p>Like this one.</p>
<p>I decided to call this “book” Linear C++, because most people believe
you can’t learn C++ in a linear fashion, and I disagree. I think
existing resources, particularly online ones, just teach things in
entirely the wrong order. They focus a lot on the low-level bits and the
syntax and never show you how the whole thing fits together as one
language, and how you can write useful programs in it with little pain.
Relatively little pain, anyway.</p>
<p>I will do my best to introduce all the concepts I use properly,
without having to resort to claims about magic. However, there are a few
things which you really do have to know first. I expect you to have
already worked in another programming language and to know how
arithmetic operators such as +, -, *, / and comparison operators such as
==, !=, &lt;, &lt;=, &gt;, &gt;= work. I also expect you to have a vague
idea of what functions, types and variables are. Finally, I’ll be using
fairly new features wherever they are useful, so make sure your compiler
can handle that. Clang is probably the most friendly compiler, but GCC
or MSVC should be fine, too.</p>
<p>There’s a number of tutorials online about setting up your compiler.
I like the ones at http://latedev.wordpress.com , but there are others
if you’d like to use an IDE not covered there. Dev-C++ is not
recommended due to being outdated. If you want to read more about the
C++ language or standard library, http://en.cppreference.com/w/ has
articles on almost everything.</p>
<p>If you have any questions, feel free to submit an issue on</p>
<p><code>https://github.com/jesyspa/linear-cpp/issues</code></p>
<p>or ask me by email to jesyspa@gmail.com</p>
<p>A note to those with experience in C: while C++ does allow a
significant portion of C, good solutions in C often aren’t particularly
good solutions in C++. I suggest working through the material without
resorting to any tricks you learned in C. In particular when it comes to
exceptions, we’ll see that the problems and solutions that result
interact poorly with C-style code.</p>
<p>Every chapter of the book is a correct program. This is only the
foreword, but it would be a pity to make it an exception, so we’ll make
it a program that does nothing.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is another kind of comment.  They will be used when talking directly</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">// about the code present, as opposed to general remarks.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">// A function called main, taking no parameters and returning an int.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>main is a very special function. It is the starting point of your
program, and its return value can be used to report if any errors
happened. A return value of 0 traditionally indicates success, and is
what we will return in most cases.</p>
<h1 id="chapter-01---hello-world">Chapter 01 - Hello World</h1>
<h2 id="main.cpp-1">main.cpp</h2>
<p>Welcome back. In the following few chapters we’ll look at how
variables work in C++, and how we can perform input and output.</p>
<p>In this example, we’ll meet the preprocessor and look at some very
basic output.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This, like any line starting with a #, is a preprocessor directive.  Such</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">// lines are instructions for manipulating the program text.  The #include</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">// directive, which is what we will use most often, states that the contents of</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">// a certain file should be inserted where the directive is.  In this case, we</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">// ask for the file iostream.  The io stands for input output, and that&#39;s what</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">// we&#39;ll be using it for.</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span></code></pre></div>
<p>Now that we have the things we need to do input and output available
to us, we can declare and define the main function. Let’s take a look at
those two terms first, though:</p>
<p>A declaration introduces a name into the program, and specifies the
type of what that name refers to. In the last program, we declared main
as an int(), which you can read as “a function taking no parameters and
returning int”. We can declare a name as many times as we want, as long
as we declare it to be the same type every time. Using a name before it
has been declared is usually not allowed; I’ll mention exceptions as we
come to them.</p>
<p>When talking about functions, a definition does everything a
declaration does but also provides the body of the function. In the
example in the foreword, we define main: if we didn’t, we’d get an error
when trying to compile the program. Every definition is automatically
also a declaration. However, unlike with declarations, it is generally
not allowed to define something multiple times. The rules become more
nuanced when we start writing programs that span multiple files, but you
can safely assume it will not work for now.</p>
<p>With these terms explained, we can now properly state why we wanted
to include iostream before doing anything else: we want to refer to
names declared in there.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Now we define (and thus also declare) the main function:</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span></code></pre></div>
<p>Output in C++ is stream-based. We have a stream, and some value we
want to put into it, and then we use the &lt;&lt; operator to insert the
value into the stream.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// More concretely, this will insert the string literal &quot;Hello world!\n&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// into the stream std::cout.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A string literal represents the text contained in it, except that some</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// character sequences (such as \n) are converted into characters you can&#39;t</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// easily write; for example, \n ends the line and goes to the next one.</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::cout is the output stream we will use most.  Anything piped into it</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// simply gets printed by the program.  You can see std::cout as a single</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// name for now.</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Putting all the above together, this will print Hello World! and then</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// end the line, so anything we print later will end up on the next line.</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Hello world!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// String literals aren&#39;t the only the only things we can print.  You can</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// print numbers, too, in exactly the same way.</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Note that this only prints 5 -- if we want to print a newline, we need to</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do that separately.</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We often want to print multiple things, and repeating std::cout over and</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// over again would get tedious.  Fortunately, we can chain insertions:</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">((((</span><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot; == &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="dv">3</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; + &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This works because the result of std::cout &lt;&lt; &quot; == &quot; is again std::cout.</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The above is equivalent to writing five statements where std::cout is</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// named every time.  Even better, though, the way the &lt;&lt; operator is</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// defined lets us skip all the parentheses and write things like:</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="dv">3</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; plus &quot;</span> <span class="op">&lt;&lt;</span> <span class="dv">2</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; equals &quot;</span> <span class="op">&lt;&lt;</span> <span class="dv">5</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This last form is what we will use most.</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The explanation that std::cout should be treated as a single name may
be unsatisfying to those with more programming experience. If you really
wish to see it as a compound entity, you can read it as “the thing named
cout from std”. There’s a variety of reasons we’d like to be able to
have different places provide things with the same name, and we’ll
eventually cover them. However, giving that whole explanation now would
be entirely unlinear, and wouldn’t help with understanding the coming
few chapters.</p>
<p>Here’s what the practical part boils down: several names separated by
:: are a compound name for something, and we currently don’t need to
distinguish compound names from non-compound ones. We will see many such
names, for types, functions, and variables, and they shouldn’t come as a
surprise. When talking about things we will sometimes drop the std::,
but we’ll always write it out in code until we get far enough for the
proper rules to be introduced.</p>
<h1 id="chapter-02---types-and-variables">Chapter 02 - Types and
Variables</h1>
<h2 id="main.cpp-2">main.cpp</h2>
<p>Now that we know how to print things, it would be nice to be able to
accept input from the user. However, at the moment, we don’t have
anywhere to put such input. Before we can start writing interactive
programs, we need to look at how to define variables, and for that we
need to know a little about types.</p>
<p>The type of a variable specifies the possible values, what operations
we can perform on that variable, and how such operations will behave.
Let’s start with a few examples:</p>
<ul>
<li><p>int is the type used for whole numbers. We can add, subtract,
multiply and divide ints, though division only gives the whole part: be
careful, as this means 2/3 == 0. There is a maximum and minimum value an
int can store; if your program adds two ints that are too large, the
results can be unpredictable and unpleasant. Dividing by zero is not
allowed.</p></li>
<li><p>double is the type used for numbers which aren’t necessarily
whole; they are sometimes also called floating point numbers. We can
add, subtract, multiply and divide doubles, but the results are not
precise. However, if you can tolerate some error, they can still be
useful. An example of a double literal is 5.3. Dividing by zero is still
not allowed.</p></li>
<li><p>bool is a type which has only two values: true and false. It is
used to represent things which can be aptly described with one of those
two words. Amongst other things, comparison operators return
bool.</p></li>
<li><p>char is a type for representing characters. We haven’t seen any
characters by themselves yet, but the string literals we used in the
last chapter were built up from them. For example, ‘a’ is of type char
and is the character a. Character literals like ‘a’ are surrounded by
single quotes, while string literals use double quotes.</p></li>
<li><p>std::string is a type used for strings; that is, fragments of
text. The types above were all primitive ones, but std::string is not,
though it is standard. In order to use an std::string, we will need to
include string. It supports a large number of operations, such as
getting the string length or getting the character at some index. Note
that string literals are not std::strings – however, we can create
std::strings from them.</p></li>
</ul>
<p>TODO: Add more about primitive vs nonprimitive types.</p>
<p>Now that we know what types are, let’s include what we need and get
into main to experiment a little.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// When our types are as simple as those above, we can define a variable</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// just by putting the type name and then the variable name we want to use.</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can now store values in x.  The stream we will be extracting out of is</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// called std::cin, and the extraction operator is &gt;&gt;.</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter a number: &quot;</span><span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now we&#39;ve extracted a number and put it in x.  We can now use this value</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// however we want; for example, let&#39;s print it back out to the user:</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;You entered: &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div>
<p>What if the user didn’t enter a number, though? If the user doesn’t
enter anything, the program will sit there and wait until there’s some
input. If the user does input something but it isn’t a number, the
situation is worse: the program will continue, but the stream will be
set into a “fail” state and the value of x won’t be anything meaningful.
We’ll learn how to check for these errors very soon.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Let&#39;s make some more variables.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now may be a good time to talk a little about what values variables get</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// when you define them.  When we&#39;re dealing with a primitive type like int,</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// double, bool or char, the value will be garbage, and you shouldn&#39;t read</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// from it until you&#39;ve given it some value.  With types like std::string,</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we don&#39;t have to worry about that: the string will be empty.</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The way we defined y here, its initial value will be the current value of</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// x.  If we want to, we can change x and y later:</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>x<span class="op">;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> y <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now y will be equal to two times the value of x, and x will equal the new</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// value of y plus five.  See:</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;y == &quot;</span> <span class="op">&lt;&lt;</span> y <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Let&#39;s try reading into our std::string.</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter a string: &quot;</span><span class="op">;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> s<span class="op">;</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;You entered: &quot;</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If you&#39;ve compiled and run this program, providing various inputs, you</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// may have noticed that only the first word you enter is read.  This is</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// because the &gt;&gt; for std::string works by ignoring any whitespace</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// characters, and then reading until it again sees a whitespace character.</span></span></code></pre></div>
<p>We’ll look at how to read lines later; due to the way the &gt;&gt;
operator works, mixing input with it and line-by-line input can give
some surprising results.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You now know enough to get input from the user, do some basic
operations on it, and then write it back out. You may want to put the
book aside for a little and write a few of your own programs to
internalize the concepts. I won’t repeat this notice at the bottom of
every chapter, but I hope to cover sufficient concepts for it to be
worth it after most, anyway.</p>
<h1 id="chapter-03---if">Chapter 03 - If</h1>
<h2 id="main.cpp-3">main.cpp</h2>
<p>Last time we looked at how to accept user input, but we couldn’t
detect invalid input. We will introduce a language construct that lets
us handle that, but first let’s take a quick refresher.</p>
<p>So far, we have seen three kinds of statements. The first we
encountered was the return statement. This let us return a value out of
a function. So far, the only function we’ve written was main, and we
always returned 0; needless to say, we’ll see much more of this later
on.</p>
<p>The second was an expression statement. This is simply a statement
that consists entirely of an expression. For example,</p>
<p><code>std::cout &lt;&lt; "Hello world!\n";</code></p>
<p>is an expression statement. Here, std::cout &lt;&lt; “Hello world!\n”
is an expression, and the semicolon turns the whole thing into a
statement.</p>
<p>Finally, we had variable definitions like</p>
<p><code>int x;</code></p>
<p>Now we’re going to introduce a fourth kind of statement: the if
statement. The syntax is as follows:</p>
<p><code>if (condition) {</code></p>
<p><code>statements...</code></p>
<p><code>}</code></p>
<p>The condition is something that results in type bool, and you can
have as many statements in the body as you’d like. If the condition
evaluates to true, the statements will be executed; otherwise, we skip
to after the if statement.</p>
<p>Without further ado, let’s get to examples.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter a number: &quot;</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Once we&#39;ve reach this point, we&#39;ve made an attempt to read an int.  We</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// can now check whether we were successful.  Streams were made in such a</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// way that we can evaluate them as bools.  If the input succeeded, std::cin</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// will be in a good state and converting it to a bool will give true.  If</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the input failed, however, std::cin will be set to &quot;fail&quot; and converting</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it to a bool will give false.  We&#39;d like to report an error if it failed,</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// so we have to invert true and false; this is done with the ! operator.</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// !true == false and !false == true.</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span><span class="bu">std::</span>cin<span class="op">)</span> <span class="op">{</span> <span class="co">// if std::cin is false</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;That&#39;s not a number!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Once a value has been returned, the function stops executing.  This</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// means that a return in main works as an &quot;early exit&quot; from the whole</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// program.</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">//</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We return 1 to indicate that the program did not complete</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// successfully.  As we will be using this program interactively it does</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// not matter much; however, this is still neater than returning 0 as if</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// everything is fine.</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Recall that std::cout &lt;&lt; &quot;Hello&quot; evaluates to std::cout.  Similarly,</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::cin &gt;&gt; y will evaluate to std::cin.  We can use this to take input</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and check whether it succeeded in one step:</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter another number: &quot;</span><span class="op">;</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!(</span><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> y<span class="op">))</span> <span class="op">{</span> <span class="co">// if reading y fails...</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;That&#39;s not a number!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>There’s another neat feature if statements have, and that’s that you
can specify some code to be executed if the condition is not true. The
syntax is:</p>
<p><code>if (condition) {</code></p>
<p><code>statements...</code></p>
<p><code>} else {</code></p>
<p><code>other_statements...</code></p>
<p><code>}</code></p>
<p>If condition is true, the first statements will be executed; if not,
the other ones will be. Once we’re done with whichever statements we are
executing we continue with the code after the else clause.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can use this to compare the two values the user entered:</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;The first number you entered is less than the second.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;The two numbers you entered are equal.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;The first number you entered is greater than the second.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// However, as you can see, we&#39;re using a lot of space to say fairly little.</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// When we only have one statement in the if or else block, we can skip the</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// curly braces and just write that one statement instead:</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;</span> y<span class="op">)</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;The second number you entered is greater than the first.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> y<span class="op">)</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;The two numbers you entered are equal.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;The second number you entered is less than the first.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Finally, you can combine multiple reads in one condition.</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter two numbers: &quot;</span><span class="op">;</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x <span class="op">&gt;&gt;</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;You did it right!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Something you entered wasn&#39;t a number.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Whether we use curly braces here or not is a matter of personal</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// preference.</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="chapter-04---while">Chapter 04 - While</h1>
<h2 id="main.cpp-4">main.cpp</h2>
<p>We now know how to check whether the input was valid, but sometimes
we’d like to let the user provide an arbitrary number of inputs and then
do something with them. For this we introduce the while statement:</p>
<p><code>while (condition) {</code></p>
<p><code>statements...</code></p>
<p><code>}</code></p>
<p>It is much like the if statement, but when all the statements in the
body are executed, we continue right above the statement, not right
below; the condition is again checked, and if it is true we do the same
thing again.</p>
<p>A problem here is knowing when to stop. We’re going to take the
simplest solution and assume that any failed read indicates that there
is no input left over. This is suboptimal, as it means we can’t easily
have multiple input loops, but the extra checks necessary otherwise
would detract from the main point of looping.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// When we want to define multiple variables of a simple type, we can write</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the type once and then write the variables separated by commas.</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> x<span class="op">,</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter as many numbers as you want:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We&#39;re going to read as much input as the user gives us, and then take the</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// average.</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// count += 1 is the same thing as count = count + 1.  We need to count</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// how many numbers the user gave us, or we won&#39;t know what to divide by</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// to get the average.</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> x<span class="op">;</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If the loop has ended, it means we failed to read a number.  Now, by our</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// assumption, it is useless to ask the user to enter anything.</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Remember: division by zero is bad.</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>count <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;No numbers entered!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Here we can calculate the average.  Let&#39;s illustrate the difference</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// between integer and floating point maths while we&#39;re at it:</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Integer average: &quot;</span> <span class="op">&lt;&lt;</span> total<span class="op">/</span>count <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// You can assign an int to a double; the value is converted as you&#39;d</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// expect it to be, though you may lose some precision if the value</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// can&#39;t be stored exactly.</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> double_total <span class="op">=</span> total<span class="op">;</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Dividing a double by an int works like dividing a double by a double.</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// All other operations work similarly; if either operand is a double,</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the whole thing becomes a double.</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Floating point average: &quot;</span> <span class="op">&lt;&lt;</span> double_total<span class="op">/</span>count <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="chapter-05---vectors">Chapter 05 - Vectors</h1>
<h2 id="main.cpp-5">main.cpp</h2>
<p>We can now take as much input from the user as we want, but we can
still only store a limited number of numbers at any one time. In this
chapter we will introduce vectors, which allow for storing an arbitrary
number of values. They are, in a way, similar to strings, which allow
you to store as many characters as you want.</p>
<p>A vector can store any of the types we named before, but any
particular vector must store only objects of one type. We can specify
what type this is when we declare the vector. For example, if we’d like
v to be a vector that stores ints, we say</p>
<p><code>std::vector&lt;int&gt; v;</code></p>
<p>Once a vector is declared to store things of a certain type, we can
not change it to store something else. On the bright side, this means
that given a vector we always know what type of things it contains. We
also have</p>
<p><code>v.size() // the number of elements in the vector</code></p>
<p><code>v.empty() // whether the vector is empty</code></p>
<p><code>v[0] // the first element</code></p>
<p><code>v[1] // the second element</code></p>
<p><code>... // etc.</code></p>
<p>As an example, we’ll write a program that reads as many numbers as
the user provides, and then finds the index of the greatest and least
elements.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">// We don&#39;t use strings in this example, but we do need to include vector to use</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">// vectors.</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Just like with std::string, if we don&#39;t specify the starting value for</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the vector it will be empty.</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter as many numbers as you want:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// push_back adds an element at the end of the vector.  This means that</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// all existing values stay where they were, and the new value has the</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// highest index.  push_front, on the other hand, puts the new element</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// at index 0 and moves the rest up; it can be useful, but is much</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// slower.</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        v<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The user has entered as many numbers as he wanted to.  Now we need to</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// loop over the vector to find the greatest and least elements.  For this</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we introduce another type.  Technically, the correct type to use is</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::vector&lt;int&gt;::size_type.  However, that&#39;s rather a mouthful and we</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// will instead use std::size_t, which is the same thing on many systems.</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// For small vectors and normal platforms this&#39;ll work.</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t greatest_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t least_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">())</span> <span class="op">{</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> v<span class="op">[</span>greatest_index<span class="op">])</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>            greatest_index <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> v<span class="op">[</span>least_index<span class="op">])</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>            least_index <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// By the way, if the user entered no numbers, we don&#39;t want to print</span></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// v[greatest_index] or v[least_index]; that would be accessing an element</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// which doesn&#39;t exist.  C++ doesn&#39;t specify what happens if we try to do</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that, but it may very well be unpleasant.</span></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Why is it okay that we&#39;re only performing this check here, and not before</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we find the greatest and least element?</span></span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;An empty sequence has no greatest or least element.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Greatest element &quot;</span> <span class="op">&lt;&lt;</span> v<span class="op">[</span>greatest_index<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; is at index &quot;</span> <span class="op">&lt;&lt;</span> greatest_index <span class="op">&lt;&lt;</span> <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Least element &quot;</span> <span class="op">&lt;&lt;</span> v<span class="op">[</span>least_index<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; is at index &quot;</span> <span class="op">&lt;&lt;</span> least_index <span class="op">&lt;&lt;</span> <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="chapter-06---for">Chapter 06 - For</h1>
<h2 id="main.cpp-6">main.cpp</h2>
<p>So far, we’ve done all looping with while. However, if you wrote some
of your own code after reading the last chapter, you probably noticed
that a lot of it looked like</p>
<p><code>std::size_t i = 0;</code></p>
<p><code>while (i &lt; v.size()) {</code></p>
<p><code>statements...</code></p>
<p><code>i += 1;</code></p>
<p><code>}</code></p>
<p>In fact, code like this is so common that there’s a special syntactic
construct when we want to do something “for every X”. Rephrased to use
it, the above becomes</p>
<p><code>// Initialisation ;  Condition  ; Step</code></p>
<p><code>for (std::size_t i = 0; i &lt; v.size(); i += 1) {</code></p>
<p><code>statements...</code></p>
<p><code>}</code></p>
<p>The initialisation is a definition or expression. You can define
multiple variables of the same type, but you cannot define multiple
variables of different types – there’s simply no room. The next part is
the condition, which is exactly like in a while loop. The last is the
step; it behaves much as if it were the last statement in the body of
the for, but is limited to being an expression.</p>
<p>Any of the three parts may be omitted. If you omit the initialisation
or step, that part will do nothing; if you omit the condition, it will
always evaluate to true. You will sometimes see for (;;) being used
instead of while (true) – the two are equivalent.</p>
<p>A little note about how variables behave: when we define a variable
in a block of code, it will not be visible outside that block. We will
have a much more rigorous explanation of this in the next chapter; for
now it suffices to say that if you define a variable in an if, while, or
for loop, including in the initialisation of the for loop, you will not
be able to use it outside that conditional or loop.</p>
<p>Let’s rewrite yesterday’s program to use a for loop.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter as many numbers as you want:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">)</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        v<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;An empty sequence has no greatest or least element.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We want greatest_index and least_index to be visible outside the loop, so</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we keep them here.</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t greatest_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t least_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i += 1 is such a common operation that there&#39;s a shortcut: ++i does</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// exactly the same thing, while --i is i -= 1.  There&#39;s also i++, which</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// increments i, but evaluates to the old value.  If you can use either one</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// prefer ++i; it&#39;s a good habit to get into for when we&#39;re dealing with</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// more complex types than just integers.</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="bu">std::</span>size_t i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> v<span class="op">[</span>greatest_index<span class="op">])</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>            greatest_index <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> v<span class="op">[</span>least_index<span class="op">])</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>            least_index <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Greatest element &quot;</span> <span class="op">&lt;&lt;</span> v<span class="op">[</span>greatest_index<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; is at index &quot;</span> <span class="op">&lt;&lt;</span> greatest_index <span class="op">&lt;&lt;</span> <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Least element &quot;</span> <span class="op">&lt;&lt;</span> v<span class="op">[</span>least_index<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; is at index &quot;</span> <span class="op">&lt;&lt;</span> least_index <span class="op">&lt;&lt;</span> <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div>
<p>It turned out that what we did with the vector is so common that even
the for syntax wasn’t quite enough. C++11 adds range-based for loops,
which allow us to not have to deal with indices. Instead, we can
write</p>
<p><code>for (int e : v) {</code></p>
<p><code>statements...</code></p>
<p><code>}</code></p>
<p>This will run statements once for every element of v, and during that
run e will be set to that element. We can’t easily get at the index any
more, but we usually don’t need it; for example, if we just want to take
the sum, we only care about the elements and not about where in the
vector they are.</p>
<p>At the moment, we also can’t modify the elements while looping over
the vector this way; however, we’ll see a way to do that fairly
soon.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> e<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Sum: &quot;</span> <span class="op">&lt;&lt;</span> total <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Integer average: &quot;</span> <span class="op">&lt;&lt;</span> total<span class="op">/</span>v<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div>
<p>If we changed the type of v from vector&lt;int&gt; to
vector&lt;double&gt;, much of the program would work. However, we’d have
to change both int total and int e above. When our programs get bigger,
changing things like this will be rather a pain. For that reason, we can
use auto in order to have the compiler figure out the correct type for
us. This isn’t a magic word that will solve all your problems, but it
can help significantly.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// For example, let&#39;s output all the elements of v:</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;v contains: &quot;</span> <span class="op">&lt;&lt;</span> e <span class="op">&lt;&lt;</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Try changing the types in this program and see what works and what</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// breaks.</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="chapter-07---functions">Chapter 07 - Functions</h1>
<h2 id="main.cpp-7">main.cpp</h2>
<p>So far I’ve introduced you to a few tools that you can use to write
programs of your own. You can read input, store as much of it as you
want, and then perform calculations using loops.</p>
<p>In this chapter, we’ll introduce you to your first meta-tool: a tool
for making tools. While you face relatively easy problems such things
may seem to cost more than they saves you, but the slightest increase in
complexity will make them irreplacable.</p>
<p>I am talking about functions.</p>
<p>We’ve already seen the main function. It had type int() and was where
we put by far most of our code. Other functions are going to have much
the same structure:</p>
<p><code>return_type function_name() {</code></p>
<p><code>statements...</code></p>
<p><code>}</code></p>
<p>This should look fairly familiar now. The function must return a
value of its return type; if we wish to not return anything we can use
the void type, of which no value can be made.</p>
<p>Before moving on to more advanced possibilities, let’s look at some
examples.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">// We often write code which reads as many numbers as the user is willing to</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">// give and stores them in a vector.  Let&#39;s write a function that does that.</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> read_int_vector<span class="op">()</span> <span class="op">{</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter as many numbers as you want:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We could use much the same implementation as we used in the last</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// examples, which assumes that if the input failed, there is nothing more</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to read.  However, let&#39;s be a little more thorough and insist that the</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// user keep entering data until they close the stream.  If a file is being</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// redirected this will happen when the end of the file is reached; when</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// entering data directly, Control-D will do the job on Linux, while</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Control-Z will work on Windows.</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Seeing as the exit condition of this loop is rather complicated, we&#39;ll</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// make it and endless loop and break out of it differently.</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Read all the input we can.</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">)</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Now we know something went wrong.  If we reached end of file, we can</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// break out of the loop.  Otherwise, we want to fix the stream and</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// continue.</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>cin<span class="op">.</span>eof<span class="op">())</span> <span class="op">{</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// The break statement does exactly what it says on the tin: it</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>            <span class="co">// breaks out of the innermost loop we happen to be in.  It has a</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>            <span class="co">// sibling: the continue statement, which skips to the end of this</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">// loop iteration, not executing all the statements left over.</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We know there&#39;s still data in the stream, and we want to access it.</span></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">// However, now that the stream is in a &quot;fail&quot; state, we won&#39;t be able</span></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">// to read anything.  We can get it back to a good state by clearing the</span></span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// error flags:</span></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We&#39;d like to tell the user what data caused us to fail, and what we</span></span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ignored.  We&#39;re going to do this by reading until the end of the line</span></span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>        <span class="co">// and stating that anything in there didn&#39;t get into our vector.</span></span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>getline<span class="op">(</span><span class="bu">std::</span>cin<span class="op">,</span> s<span class="op">);</span> <span class="co">// read a line from std::cin into s</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Rember how I said line-by-line input and the &gt;&gt; operator don&#39;t always</span></span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">// mix?  That&#39;s because of how the &gt;&gt; operator deals with whitespace.</span></span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If it read something from the stream, it will leave all the</span></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a>        <span class="co">// whitespace after it still in there.  That means that when you enter 5</span></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a>        <span class="co">// and press enter, &gt;&gt; will read the five and leave the newline.  When</span></span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we then do a getline, that newline will be the &quot;end of the line&quot;, so</span></span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we won&#39;t get a chance to enter any new data.</span></span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">//</span></span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Here, we can mix the two because we&#39;re reading after a &gt;&gt; attempt</span></span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">// failed.  That means that it already got through all the whitespace</span></span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">// and what&#39;s next is data we may be interested in.</span></span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Warning, ignoring: &quot;</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We&#39;ve read all the input we possibly could.  Let&#39;s thank the user and</span></span>
<span id="cb20-67"><a href="#cb20-67" aria-hidden="true" tabindex="-1"></a>    <span class="co">// return the values to the rest of the program.</span></span>
<span id="cb20-68"><a href="#cb20-68" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;End of file encountered, stopping input.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb20-69"><a href="#cb20-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb20-70"><a href="#cb20-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-71"><a href="#cb20-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-72"><a href="#cb20-72" aria-hidden="true" tabindex="-1"></a><span class="co">// Well, that was a mouthful!  However, in all the programs we write from this</span></span>
<span id="cb20-73"><a href="#cb20-73" aria-hidden="true" tabindex="-1"></a><span class="co">// point on, we won&#39;t have to repeat this code.  The details will come in the</span></span>
<span id="cb20-74"><a href="#cb20-74" aria-hidden="true" tabindex="-1"></a><span class="co">// next chapter; for now, let&#39;s take a look at a few more functions.</span></span></code></pre></div>
<p>The function we wrote above allows us to execute a block of code from
wherever we want and have it give us back a value. What we’ll do now is
parametrise that block of code by a value. That is, we’ll make the
function accept values from the caller. Those values are copied, so
setting them only changes what the function sees, not what the caller
sees. However, this also means the function has full freedom to do what
it wants with them, without anyone ever finding out.</p>
<p>For a function to accept parameters we have to expand our syntax a
little:</p>
<p><code>return_type function_name(param_type1 param1, param_type2 param2 ...) {</code></p>
<p><code>statements...</code></p>
<p><code>}</code></p>
<p>Parameters are like local variables, but their value is specified
from outside the function. Suppose we define</p>
<p><code>int square(int x) {</code></p>
<p><code>return x*x;</code></p>
<p><code>}</code></p>
<p>we have a function square that we can call with an int; for example
square(5) would be a valid call. square would be executed with x
initialised to 5, and after it has returned x*x, the original square(5)
would evaluate to 25.</p>
<p>Recall that we can declare a function by omitting the body
(statements and braces) and putting a semicolon after the list of
parameters. Let’s first declare some functions and define them
later.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Function that, given a vector, returns the average of the elements.</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> average<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">);</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Function that, given a vector, returns the sum of the elements.</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">);</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Function that, given a vector and int, returns a vector of all elements</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">// greater than the given int.</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_greater_than<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">,</span> <span class="dt">int</span> x<span class="op">);</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We already know read_int_vector will give us an std::vector&lt;int&gt;, and the</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// compiler knows that, too.  Writing it out explicitly wouldn&#39;t tell anyone</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// anything new, so we use auto and the compiler will assume that v is the</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// type of whatever read_int_vector gave us.</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> read_int_vector<span class="op">();</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We&#39;ve declared average, sum, and filter_greater_than so we can use them,</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// even though they haven&#39;t yet been defined.  This is one of the powerful</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// things about declarations; we can worry about the definitions much, much</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// later.</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Average: &quot;</span> <span class="op">&lt;&lt;</span> average<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Sum: &quot;</span> <span class="op">&lt;&lt;</span> sum<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can use the return value of filter_greater_than in a range-based for.</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Note that there&#39;s no easy way of rewriting this to be a normal for loop.</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Elements greater than 5:&quot;</span><span class="op">;</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> filter_greater_than<span class="op">(</span>v<span class="op">,</span> <span class="dv">5</span><span class="op">))</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">;</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a><span class="co">// While we can put off writing the definitions, we do have to do it eventually.</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> average<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The average of a number is the sum divided by the number of elements.</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Let&#39;s define the average of an empty vector to be 0; this makes some</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sense, and means we don&#39;t have to check for empty vectors so often.</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Notice that we can write this function without writing any loops.</span></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// They&#39;re still there in the compiled program, but we as the programmer</span></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// don&#39;t need to explain how to get the sum of a vector every time we want</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it.</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// As we&#39;ve seen before, the type of v.size() is std::size_t.  We want the</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// result to be an int, so we create an int out of v.size() before using it.</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> v<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum<span class="op">(</span>v<span class="op">)/</span>size<span class="op">;</span></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We&#39;ve done this before, and it&#39;s not hard.  It&#39;s also the last time we&#39;ll</span></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">// have to do it explicitly again!</span></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> e<span class="op">;</span></span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now that we’ve gotten to parameter passing and looked at how it works
in practice, let’s take a look at how it works and what is and isn’t
allowed.</p>
<p>First of all, there’s the question of scope. If you define a variable
inside a set of curly braces, you will not be able to use it outside it.
The same thing works with functions: a variable defined in a function
stays within that function. If you want a value from one function to end
up in another function, then the only ways we know of so far are by
passing it as a parameter or by returning it. Notice that the functions
are so isolated it may even appear like we’re breaking the
one-definition-only rule: all three of main, average and sum define a
variable v!</p>
<p>The reason this is allowed is that those three variables, even though
they all have the same name, reside in different functions and so are
entirely distinct. They don’t know about each-others’ existence, can’t
change each others’ data, and we could rename any of the three with no
effect on the rest. In this particular program they all have the same
value, but that is coincidental.</p>
<p>By the way, saying that there are three of them is not entirely
correct. Every time you call a function, all of the variables used
inside it are created, and when the function is complete they are
destroyed. When main calls sum and passes it v, the v and total in sum
are created, total is changed, its value is returned, and both v and
total are again destroyed.</p>
<p>When average calls sum and passes it its v, the process happens
again. This isn’t particularly efficient, as we end up calculating the
sum twice. Even worse, we end up copying the vector every time we pass
it to a function! We will see how to make this less slow later; for now,
understanding functions is much more important than writing blazing-fast
code.</p>
<p>The way independent variables are created and destroyed every time a
function is called is best illustrated with recursive functions:
functions that call themselves. Some problems naturally have
significantly more elegant recursive solutions than iterative ones.</p>
<p>TODO: Add a fitting example.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_greater_than<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>e <span class="op">&gt;</span> x<span class="op">)</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span>e<span class="op">);</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The next few chapters will be about some practical aspects of using
functions and some nuances in the rules regarding them.</p>
<p>Functions are important. So far, these chapters have been fairly
low-level and focused on getting you acquainted with the basic syntax.
Make sure you are comfortable with all of these: we’re now going to
spend some time looking at what we can do with the current tools, what
the standard library has to offer us, and what new features we’d like to
have.</p>
<h1 id="chapter-08---using-multiple-files">Chapter 08 - Using Multiple
Files</h1>
<h2 id="main.cpp-8">main.cpp</h2>
<p>Suggested reading order: main.cpp, vector_algos.hpp,
vector_algos.cpp</p>
<p>This chapter is unlike all the previous ones, because instead of
having a single main.cpp file the directory should contain main.cpp,
vector_algos.hpp and vector_algos.cpp. We’re going to leave the previous
program almost unchanged, but instead of lumping everything together
into one file we’ll neatly split it out. You can see our main function
below: it is entirely unchanged.</p>
<p>The new files added are another source file and a header file. The
source file, vector_algos.cpp, behaves just like main.cpp; it will be
compiled the same way, as described further. We are going to define all
our algorithms for working on vectors in there.</p>
<p>The header file, vector_algos.hpp, is somewhat different. We will not
give it to the compiler directly; instead, we will include it in our
source files. This is only marginally useful in this example, as only
main.cpp really needs to include it. However, as our projects grow large
we won’t want to duplicate all our function declarations by hand.
Instead, we will write them in header files and use include directives
to copy their contents into our source files.</p>
<p>This is exactly what the include directive does: it takes everything
in that file and literally copy-pastes it where our include directive
was. Do not expect any kind of special treatment: if you include a file
twice, it will be pasted in twice. If file A includes file B, and file B
includes file C, file A will get a copy of file C inside it. If file A
includes file B, and file B includes file A, your program will not
compile.</p>
<p>What happens when a program is compiled, anyway? The process can be
split into three stages:</p>
<ul>
<li>First of all, the preprocessor is run over all the files. This
removes comments and handles all preprocessor directives. After this,
every source file has become a single compilable entity called a
Translation Unit. Header files are no longer necessary.</li>
<li>Secondly, the compiler runs on each source file and outputs an
object file. This is the compiled code for that one file; it is not yet
an executable, as not all functions are necessarily defined. It is here
that most of the translation is done; after this step, finding the C++
code back is not possible.</li>
<li>Thirdly, the linker takes all our object files and then links them
into an executable, which we can run.</li>
</ul>
<p>Why not glue all the source files together before compiling? C++ is a
complex language, and compiling it takes a long time. By doing the
preprocessing and compiling separately for every file, we don’t need to
recompile translation units that haven’t changed since we last compiled.
Only linking needs to look at all of the files, but that is relatively
fast. Even for small projects, this can make the difference between
being able to test your changes directly and having to wait a minute or
two for it to build.</p>
<p>Because of this, it is a good idea to minimize the number of things
you include: the more headers a file depends on, the more likely it is
it will need to be recompiled. The advice boils down to “include
everything you need, and no more”, which admittedly is not all that
specific.</p>
<p>You might have noticed that so far, we’ve not seen the preprocessed
files or object files. This is because with a project this small, we can
ask the compiler to keep the results in memory between the steps. Even
with bigger projects, the preprocessing output is usually not stored;
object files, however, are usually written to disk for reusability.</p>
<p>Enough chatter, let’s look at the program.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">// What to include and in what order is an interesting question.  Due to the</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">// copy-paste nature of includes, if vector_algos.hpp includes iostream and</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co">// vector, we don&#39;t need to include those two.  Can we be sure it will, though?</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">// We know that the only work we do on vectors is with the functions from it, so</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">// that&#39;s fine.  We don&#39;t have any reason to be sure it will include iostream,</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">// though, so we include that ourselves.</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">// As to the order, you should do your best to stop includees relying on the</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co">// prior includes of their includers.  A mouthful?  Let&#39;s say A includes B and</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co">// then C.  If C needs B, C should include B itself, not rely on A including B</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co">// first.  Thus, include your own headers first of all, then the headers of the</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="co">// third-party libraries you use, and finally the standard library headers.</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;vector_algos.hpp&quot;</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="co">// Look at how clean and simple this is!</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="co">// Once you&#39;re done admiring it, read vector_algos.hpp</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> read_int_vector<span class="op">();</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Average: &quot;</span> <span class="op">&lt;&lt;</span> average<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Sum: &quot;</span> <span class="op">&lt;&lt;</span> sum<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Elements greater than 5:&quot;</span><span class="op">;</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> filter_greater_than<span class="op">(</span>v<span class="op">,</span> <span class="dv">5</span><span class="op">))</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">;</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// By the way, we&#39;ve been writing return 0; at the end of every main</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// function.  As I said before, the main function is weird: for example, you</span></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// can&#39;t call it from inside your program.  Another (nice) quirk it has is</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that you are allowed to omit the return statement at the end, and the</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// compiler will assume you returned 0.  This means we can stop writing it</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// out now and let the compiler do the work.</span></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// As you may have noticed, I&#39;m extremely lazy and love letting software do</span></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// work for me.</span></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="vector_algos.cpp">vector_algos.cpp</h2>
<p>This is a fairly simple file. We copy over the functions in the last
chapter. Nothing special has to be done here.</p>
<p>Perhaps important to note is that while we need to declare things in
main.cpp (or a header it includes) for them to be visible during the
compilation stage, everything we define in this file will by default be
visible in the linker stage. That means that functions we define can
still cause double definition errors. We will see how to fix that
later.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;vector_algos.hpp&quot;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> read_int_vector<span class="op">()</span> <span class="op">{</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter as many numbers as you want:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">)</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>cin<span class="op">.</span>eof<span class="op">())</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>getline<span class="op">(</span><span class="bu">std::</span>cin<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Warning, ignoring: &quot;</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;End of file encountered, stopping input.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> e<span class="op">;</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_greater_than<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>e <span class="op">&gt;</span> x<span class="op">)</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span>e<span class="op">);</span></span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="vector_algos.hpp">vector_algos.hpp</h2>
<p>As we said in main.cpp, everything in this file will be copy-pasted
into all files that include it. In this project, this means main.cpp and
vector_algos.cpp.</p>
<p>Remember how we weren’t allowed to define things twice? This is going
to change a little now that we are using multiple files. We are still
only ever allowed to define things once per file, but there are things
which we may define in multiple files, as long as we define all of them
the same way.</p>
<p>Functions usually aren’t one of these things, but we can make an
exception for a specific function by marking it inline. We’ll do that
here with average as an example. There are a lot of trade-offs to
consider when choosing to do this; I won’t go into the details here, but
you may want to consult further sources when doing this in a real
project.</p>
<p>Even with inline, we still have a problem. Recall that if a file is
included twice, its contents will appear twice. A definition might then
be present in a translation unit twice, which is not allowed. To avoid
these problems we use the preprocessor. It allows us to define
macros:</p>
<p><code>#define MACRO_NAME arbitrary text</code></p>
<p>When MACRO_NAME (which is traditionally written in uppercase) is
encountered, the arbitrary text is inserted where it was. This can be a
powerful tool, but often of the “blow up in your face” variety. We won’t
use the text portion for now; instead, we’ll use the ifndef directive,
which stands for “if not defined”:</p>
<p><code>#ifndef MACRO_NAME</code></p>
<p><code>code...</code></p>
<p><code>#endif</code></p>
<p>The preprocessor knows what macros are defined. If MACRO_NAME is not
defined in the example above, the code is left as-is. If it is defined,
however, the whole block is erased and all that ends up in the
preprocessed translation unit are empty lines, if that. We will surround
all our code with an ifndef, and then define the macro it checks for
inside it; that way, the code will be kept the first time, but erased
the second, preventing duplicate definitions.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Check whether we&#39;ve already included this file...</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_08_VECTOR_ALGOS_HPP</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Mark that we&#39;ve included it...</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_08_VECTOR_ALGOS_HPP</span></span></code></pre></div>
<p>By the way… Modern compilers have noticed that these kind of guards
are used by everyone and their preprocessor supports #pragma once, which
does something much like the above. This saves some pain; for example,
imagine if two files used CHAPTER_08_VECTOR_ALGOS_HPP to guard
themselves?</p>
<p>This isn’t a standard feature yet, so before using #pragma once, make
sure you’ll only be using compilers that do support it.</p>
<p>Also, some people will use names like
__CHAPTER_08_VECTOR_ALGOS_HPP__. While they will often work, any names
with two consecutive underscores (or starting with an underscore
followed by a capital letter) are reserved. If you use them, it’s your
own fault if your program breaks.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Now let&#39;s put our declarations.  Note that I changed the comments a little;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="co">// they were more explicit than they had to be; the types are already mentioned</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co">// in the signature, so we don&#39;t have to repeat them in the description.</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Very persistently get a vector from std::cin.</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> read_int_vector<span class="op">();</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Calculate sum of all vector element values.</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">);</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Copy the vector, leaving only elements greater than x.</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_greater_than<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">,</span> <span class="dt">int</span> x<span class="op">);</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="co">// inline is not part of the return type; rather, it documents that average may</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="co">// be defined multiple times in our program, though only once per .cpp file, and</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="co">// all definitions must be the same.</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> average<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> v<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum<span class="op">(</span>v<span class="op">)/</span>size<span class="op">;</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a><span class="co">// We only want to &quot;guard&quot; the portion above.</span></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a><span class="co">// Take a look at vector_algos.cpp now.</span></span></code></pre></div>
<h1 id="chapter-09---iterators">Chapter 09 - Iterators</h1>
<h2 id="main.cpp-9">main.cpp</h2>
<p>Suggested reading: main.cpp, vector_algos.hpp, vector_algos.cpp</p>
<p>We’re going to write some more functions now. We’ll start by
implementing a sorting algorithm and then implement a binary search
function. Binary search lets us find a value in a vector faster, but it
requires that the vector be sorted.</p>
<p>Let’s take a look at the main function first, which gives a
high-level overview of what’s going on:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;vector_algos.hpp&quot;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Looking at this code, we can deduce that sort probably has type</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      std::vector&lt;int&gt;(std::vector&lt;int&gt;)</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and binary_search has type</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      bool(std::vector&lt;int&gt;, int)</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> read_int_vector<span class="op">();</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sorted_v <span class="op">=</span> sort<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;You entered:&quot;</span><span class="op">;</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> sorted_v<span class="op">)</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">;</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>binary_search<span class="op">(</span>sorted_v<span class="op">,</span> i<span class="op">))</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot; was amongst the numbers you entered.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot; was not amongst the numbers you entered.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="vector_algos.cpp-1">vector_algos.cpp</h2>
<p>Now we’re getting to the interesting stuff! We’ll leave
read_int_vector as-is; go ahead and look below it for the cool new
stuff.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;vector_algos.hpp&quot;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a header we&#39;ve not seen before; it allows us to use some features of</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co">// vectors.  I&#39;ll introduce what exactly it brings in when we get to it.</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co">// One thing I&#39;ll say already, though, is that we will be using a type called</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co">// std::vector&lt;int&gt;::iterator a lot.  It will be introduced very soon; for now I</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="co">// want to save us some typing and give it a shorter name.</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> iterator <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>iterator<span class="op">;</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="co">// The above makes iterator another name for std::vector&lt;int&gt;::iterator.</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> read_int_vector<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter as many numbers as you want:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">)</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>cin<span class="op">.</span>eof<span class="op">())</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>getline<span class="op">(</span><span class="bu">std::</span>cin<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Warning, ignoring: &quot;</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;End of file encountered, stopping input.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> sort<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">{</span></span></code></pre></div>
<p>The sorting algorithm we’ll be implementing is called quicksort. It
works as follows:</p>
<ul>
<li>Take a vector. If it is empty or has one element, we are done.</li>
<li>Otherwise, choose an element x from it.</li>
<li>Rearrange the vector so that all elements less than x are to the
left of x, and all elements greater than or equal to are to the
right.</li>
<li>Quicksort all the elements to the left of x, then all elements to
the right of x.</li>
</ul>
<p>This may feel like cheating: we’re making use of quicksort while
we’re defining what it is! Never the less, we’ll be able to write the
code exactly like this and it’ll work. That’s because every time we use
quicksort we use it on a smaller vector than before: eventually, we’ll
get to vectors that are empty or have one element, and there we don’t
call quicksort any more. This pattern of a function calling itself is
called recursion.</p>
<p>We could go and write this using just the things we know already, but
the number of copies that we’d need to make would be overwhelming. Every
time we want to wanted to sort a part of the vector we’d have to copy
that part into a separate vector, sort it (more copies!), and then copy
it back. Wouldn’t it be nice if there was some way to indicate a
“subvector”?</p>
<p>As usual, it turns out there is. The solution is to pass not a vector
but an iterator range. An iterator is a general concept, but we’ll be
specifically working with std::vector&lt;int&gt;::iterators today. It’s
a random access iterator, which gives us the most freedom when using it.
We’ll look at other kinds of iterators later; some of what I say here
might not apply to them.</p>
<p>Getting an iterator is easy: v.begin() and v.end() both give us
iterators. v.begin() is the iterator corresponding to the first element
of v. v.end() is the iterator corresponding to one past the last
element. That means that v.end() does not have an associated element! It
turns out that having this “imaginary element” makes many things easier.
For example, if the vector is empty, v.begin() will also refer to the
imaginary element, and we know that v is empty if and only if v.begin()
== v.end().</p>
<p>But, let’s say we have an iterator:</p>
<p><code>auto it = v.begin(); // auto becomes std::vector&lt;int&gt;::iterator</code></p>
<p>What can we do? As we showed with v.end() above, we can compare
iterators. We can also add a value to an iterator:</p>
<p><code>it += 2; // now v.begin() refers to the third element.</code></p>
<p>Usually we want to go one element at a time, and so we use ++it.</p>
<p>Finally, we can get what element an iterator refers to by
dereferencing it:</p>
<p><code>int i = *it; // same as int i = v[2]; here.</code></p>
<p>Note that this is only allowed if it refers to an element – *v.end()
is not allowed. (More precisely, it isn’t defined: the result is
unpredictable and likely unpleasant.)</p>
<p>Now that we know the basic operations iterators support, we can write
our sorting function!</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We&#39;ll start by defining two helper functions.  One does the rearranging</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// step, and we&#39;ll call it partition.  It takes the range it should</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// rearrange, uses the first element of that range to perform the</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// rearranging (we call that element the pivot), and then returns an</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// iterator to where the pivot ended up.</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The other function will perform the result of the algorithm.  It doesn&#39;t</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// need to return anything, but it takes the range to be sorted.  Our sort</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// function delegates most of its work to it; I find that this makes the</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// name sort_impl a good choice, as it is the &quot;real implemenation&quot; of the</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sort function.</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Recall that we made iterator another name for std::vector&lt;int&gt;::iterator.</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now&#39;s the time to make use of that and save us some typing!</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    iterator partition<span class="op">(</span>iterator begin<span class="op">,</span> iterator end<span class="op">);</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> sort_impl<span class="op">(</span>iterator begin<span class="op">,</span> iterator end<span class="op">);</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// As v is already a copy, we can sort it in-place and then return it.</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>    sort_impl<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v<span class="op">;</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sort_impl<span class="op">(</span>iterator begin<span class="op">,</span> iterator end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Redeclaration; our previous one was only in the scope of sort.</span></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>    iterator partition<span class="op">(</span>iterator begin<span class="op">,</span> iterator end<span class="op">);</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Here comes the real work!  First of all, we want to know whether the</span></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// range [begin,end) contains more than one element.  Just like we can add a</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// number to an iterator, we can subtract two iterators to get the number of</span></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// elements in the range they create.  If we have one or less, we&#39;d like to</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// return.</span></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>end <span class="op">-</span> begin <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// sort_impl returns void, so what value do we give when returning from</span></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// it?  No value is fine.  (Don&#39;t try this in a non-void function.)</span></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Let&#39;s partition the thing and see what the two subranges we get are.</span></span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pivot <span class="op">=</span> partition<span class="op">(</span>begin<span class="op">,</span> end<span class="op">);</span></span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The first subrange is [begin,pivot).  Note that pivot acts as the end</span></span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// iterator here, so even though though there is an element at that</span></span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// position, we can assume our algorithms won&#39;t do anything with it.</span></span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We know that pivot is already in the correct position (how?).  We also</span></span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// know that pivot != end, so we can increment pivot.  We thus use pivot+1</span></span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// as the beginning of our second range, and this will be correct.</span></span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a>    sort_impl<span class="op">(</span>begin<span class="op">,</span> pivot<span class="op">);</span></span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a>    sort_impl<span class="op">(</span>pivot<span class="op">+</span><span class="dv">1</span><span class="op">,</span> end<span class="op">);</span></span>
<span id="cb29-49"><a href="#cb29-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-50"><a href="#cb29-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-51"><a href="#cb29-51" aria-hidden="true" tabindex="-1"></a>iterator partition<span class="op">(</span>iterator begin<span class="op">,</span> iterator end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-52"><a href="#cb29-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now for the partitioning.  We&#39;ll want to iterate over the range and keep</span></span>
<span id="cb29-53"><a href="#cb29-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// track of where the pivot is.  We know the range isn&#39;t empty, so we can</span></span>
<span id="cb29-54"><a href="#cb29-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">// increment begin.  Notice how we&#39;re using postincrement; this means the</span></span>
<span id="cb29-55"><a href="#cb29-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">// value of begin is changed, but pivot still gets the old value.</span></span>
<span id="cb29-56"><a href="#cb29-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb29-57"><a href="#cb29-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We need to put this outside the for loop because we want to use it later.</span></span>
<span id="cb29-58"><a href="#cb29-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pivot <span class="op">=</span> begin<span class="op">++;</span></span>
<span id="cb29-59"><a href="#cb29-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-60"><a href="#cb29-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(;</span> begin <span class="op">!=</span> end<span class="op">;</span> <span class="op">++</span>begin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-61"><a href="#cb29-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*</span>pivot <span class="op">&gt;</span> <span class="op">*</span>begin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-62"><a href="#cb29-62" aria-hidden="true" tabindex="-1"></a>            <span class="co">// We use a handy function called std::swap.  It swaps the values of</span></span>
<span id="cb29-63"><a href="#cb29-63" aria-hidden="true" tabindex="-1"></a>            <span class="co">// two variables.  Here, swapping *pivot and *begin means swapping</span></span>
<span id="cb29-64"><a href="#cb29-64" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the values of two vector elements.</span></span>
<span id="cb29-65"><a href="#cb29-65" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-66"><a href="#cb29-66" aria-hidden="true" tabindex="-1"></a>            <span class="co">// If we find an element that should go before the pivot, we swap it</span></span>
<span id="cb29-67"><a href="#cb29-67" aria-hidden="true" tabindex="-1"></a>            <span class="co">// with the pivot.  We then move the pivot iterator one further, and</span></span>
<span id="cb29-68"><a href="#cb29-68" aria-hidden="true" tabindex="-1"></a>            <span class="co">// swap the now-pivot with that.</span></span>
<span id="cb29-69"><a href="#cb29-69" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-70"><a href="#cb29-70" aria-hidden="true" tabindex="-1"></a>            <span class="co">// For example, let 3 be the pivot:</span></span>
<span id="cb29-71"><a href="#cb29-71" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-72"><a href="#cb29-72" aria-hidden="true" tabindex="-1"></a>            <span class="co">//      1, 3, 5, 7, 6, 2, 4, 8,</span></span>
<span id="cb29-73"><a href="#cb29-73" aria-hidden="true" tabindex="-1"></a>            <span class="co">//         ^           ^        ^</span></span>
<span id="cb29-74"><a href="#cb29-74" aria-hidden="true" tabindex="-1"></a>            <span class="co">//   pivot |     begin |    end |</span></span>
<span id="cb29-75"><a href="#cb29-75" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-76"><a href="#cb29-76" aria-hidden="true" tabindex="-1"></a>            <span class="co">// We swap *pivot and *begin:</span></span>
<span id="cb29-77"><a href="#cb29-77" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-78"><a href="#cb29-78" aria-hidden="true" tabindex="-1"></a>            <span class="co">//      1, 2, 5, 7, 6, 3, 4, 8,</span></span>
<span id="cb29-79"><a href="#cb29-79" aria-hidden="true" tabindex="-1"></a>            <span class="co">//         ^           ^        ^</span></span>
<span id="cb29-80"><a href="#cb29-80" aria-hidden="true" tabindex="-1"></a>            <span class="co">//   pivot |     begin |    end |</span></span>
<span id="cb29-81"><a href="#cb29-81" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-82"><a href="#cb29-82" aria-hidden="true" tabindex="-1"></a>            <span class="co">// We increment the pivot iterator</span></span>
<span id="cb29-83"><a href="#cb29-83" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-84"><a href="#cb29-84" aria-hidden="true" tabindex="-1"></a>            <span class="co">//      1, 2, 5, 7, 6, 3, 4, 8,</span></span>
<span id="cb29-85"><a href="#cb29-85" aria-hidden="true" tabindex="-1"></a>            <span class="co">//            ^        ^        ^</span></span>
<span id="cb29-86"><a href="#cb29-86" aria-hidden="true" tabindex="-1"></a>            <span class="co">//      pivot |  begin |    end |</span></span>
<span id="cb29-87"><a href="#cb29-87" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-88"><a href="#cb29-88" aria-hidden="true" tabindex="-1"></a>            <span class="co">// And then we swap *pivot and *begin again:</span></span>
<span id="cb29-89"><a href="#cb29-89" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-90"><a href="#cb29-90" aria-hidden="true" tabindex="-1"></a>            <span class="co">//      1, 2, 3, 7, 6, 5, 4, 8,</span></span>
<span id="cb29-91"><a href="#cb29-91" aria-hidden="true" tabindex="-1"></a>            <span class="co">//            ^        ^        ^</span></span>
<span id="cb29-92"><a href="#cb29-92" aria-hidden="true" tabindex="-1"></a>            <span class="co">//      pivot |  begin |    end |</span></span>
<span id="cb29-93"><a href="#cb29-93" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb29-94"><a href="#cb29-94" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Now pivot again refers to 3, all elements to the left of it are</span></span>
<span id="cb29-95"><a href="#cb29-95" aria-hidden="true" tabindex="-1"></a>            <span class="co">// less than 3, and all elements between it and begin are greater</span></span>
<span id="cb29-96"><a href="#cb29-96" aria-hidden="true" tabindex="-1"></a>            <span class="co">// than 3.</span></span>
<span id="cb29-97"><a href="#cb29-97" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>swap<span class="op">(*</span>pivot<span class="op">,</span> <span class="op">*</span>begin<span class="op">);</span></span>
<span id="cb29-98"><a href="#cb29-98" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span>pivot<span class="op">;</span></span>
<span id="cb29-99"><a href="#cb29-99" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>swap<span class="op">(*</span>pivot<span class="op">,</span> <span class="op">*</span>begin<span class="op">);</span></span>
<span id="cb29-100"><a href="#cb29-100" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-101"><a href="#cb29-101" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-102"><a href="#cb29-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-103"><a href="#cb29-103" aria-hidden="true" tabindex="-1"></a>    <span class="co">// At the end, pivot refers to where our pivot is, so we can just return it.</span></span>
<span id="cb29-104"><a href="#cb29-104" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pivot<span class="op">;</span></span>
<span id="cb29-105"><a href="#cb29-105" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-106"><a href="#cb29-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-107"><a href="#cb29-107" aria-hidden="true" tabindex="-1"></a><span class="co">// Phew!  Now we&#39;ve gotten sorting working, let&#39;s implement searching.  The</span></span>
<span id="cb29-108"><a href="#cb29-108" aria-hidden="true" tabindex="-1"></a><span class="co">// algorithm is based on a similar principle.  We know that the vector is</span></span>
<span id="cb29-109"><a href="#cb29-109" aria-hidden="true" tabindex="-1"></a><span class="co">// sorted, so if we encounter an element greater than the element we&#39;re looking</span></span>
<span id="cb29-110"><a href="#cb29-110" aria-hidden="true" tabindex="-1"></a><span class="co">// for, we can assume it isn&#39;t in any of the above.  We can put a similar lower</span></span>
<span id="cb29-111"><a href="#cb29-111" aria-hidden="true" tabindex="-1"></a><span class="co">// bound, and by always looking at the number in the middle of the bound we&#39;ll</span></span>
<span id="cb29-112"><a href="#cb29-112" aria-hidden="true" tabindex="-1"></a><span class="co">// be able to narrow down our search very quickly.</span></span>
<span id="cb29-113"><a href="#cb29-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-114"><a href="#cb29-114" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> binary_search<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">,</span> <span class="dt">int</span> val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-115"><a href="#cb29-115" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We name our bounds bottom and top.</span></span>
<span id="cb29-116"><a href="#cb29-116" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> bottom <span class="op">=</span> v<span class="op">.</span>begin<span class="op">(),</span> top <span class="op">=</span> v<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb29-117"><a href="#cb29-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>top <span class="op">!=</span> bottom<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-118"><a href="#cb29-118" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Find an element half-way in the range.</span></span>
<span id="cb29-119"><a href="#cb29-119" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> mid <span class="op">=</span> bottom <span class="op">+</span> <span class="op">(</span>top <span class="op">-</span> bottom<span class="op">)/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb29-120"><a href="#cb29-120" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The way we choose subranges here is similar to how we choose them</span></span>
<span id="cb29-121"><a href="#cb29-121" aria-hidden="true" tabindex="-1"></a>        <span class="co">// with quicksort.  If our range is bounded by mid from above, mid as</span></span>
<span id="cb29-122"><a href="#cb29-122" aria-hidden="true" tabindex="-1"></a>        <span class="co">// end works fine.  If from below, we want to exclude mid from it.</span></span>
<span id="cb29-123"><a href="#cb29-123" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*</span>mid <span class="op">&lt;</span> val<span class="op">)</span></span>
<span id="cb29-124"><a href="#cb29-124" aria-hidden="true" tabindex="-1"></a>            bottom <span class="op">=</span> mid<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb29-125"><a href="#cb29-125" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(*</span>mid <span class="op">&gt;</span> val<span class="op">)</span></span>
<span id="cb29-126"><a href="#cb29-126" aria-hidden="true" tabindex="-1"></a>            top <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb29-127"><a href="#cb29-127" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb29-128"><a href="#cb29-128" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb29-129"><a href="#cb29-129" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-130"><a href="#cb29-130" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If bottom == top, the range of possible elements is empty and so we</span></span>
<span id="cb29-131"><a href="#cb29-131" aria-hidden="true" tabindex="-1"></a>    <span class="co">// haven&#39;t found it.</span></span>
<span id="cb29-132"><a href="#cb29-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb29-133"><a href="#cb29-133" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>At the moment, our binary search only checks whether the value is in
the vector. It doesn’t specify where in the vector it is; had we wanted
to do that, we’d have to come up with some value to use for an invalid
index. We could use the size of the vector, or -1, or some other value
that cannot otherwise be attained, but that’s hardly a neat
solution.</p>
<p>What if we returned an iterator? v.end() would be the idiomatic value
to return, and the changes to the code would be minor. It would,
however, be a grave error in this case. When we call binary_search we
pass it a vector. That vector is copied and is called v inside
binary_search. When we return from binary_search, v will be destroyed,
and any iterators still refering to its elements will become unusable:
if we returned one to the caller, it wouldn’t be able to do anything
with it.</p>
<p>Speaking of nasty things: don’t compare iterators from different
vectors. The result you get won’t be meaningful.</p>
<p>We can run into a similar bug with function return values. For
example:</p>
<p><code>auto it = filter_greater_than(v, 5).begin();</code></p>
<p>If v is an std::vector&lt;int&gt; this will compile. However, the
vector returned by filter_greater_than is a temporary. Temporaries exist
until the outermost expression they are part of has been evaluated
fully. In this case, that’s the expression filter_greater_than(v,
5).begin(). That means that by the next statement, the temporary has
been destroyed and the value in it is unusable.</p>
<p>Knowing how long things live for is a critical part of writing
correct C++ programs. We didn’t have to worry about it until now, due to
there being no way to refer to an object that has been destroyed; now
that iterators are in the picture, extra care must be taken.</p>
<p>Now that you know iterators, try rewriting the program we’ve written
earlier to use them. In the next chapter we’ll take a look at how to
save ourselves some copying with references.</p>
<h2 id="vector_algos.hpp-1">vector_algos.hpp</h2>
<div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_09_VECTOR_ALGOS_HPP</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_09_VECTOR_ALGOS_HPP</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> read_int_vector<span class="op">();</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Well, what do you know, we were right about both!</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> sort<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">);</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> binary_search<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">,</span> <span class="dt">int</span> val<span class="op">);</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="co">// I suppose it isn&#39;t entirely fair, as I was the one to choose them...</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="co">// There&#39;s nothing surprising or new in this header; let&#39;s go on to</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="co">// vector_algos.cpp</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-10---references">Chapter 10 - References</h1>
<h2 id="main.cpp-10">main.cpp</h2>
<p>Suggested reading order: main.cpp, vector_algos.hpp,
vector_algos.cpp</p>
<p>Now that we’ve seen a few functions, we’re going to come back and fix
the main performance issue we spotted: the fact we’re passing vectors by
value everywhere, causing a significant amount of copying to happen.</p>
<p>When we say “a copy is made”, we mean that the original value is read
from but not modified in any way. The function only deals with this
copy, and any changes it makes aren’t visible; we could see that in the
sort example in the last chapter.</p>
<p>We could rewrite all our functions to take iterator pairs, and there
are some good reasons to do that. However, it is not always the most
convenient solution; for example, taking the sum of a filtered vector
would require that we store the result of filter_greater_than, instead
of directly passing it to sum.</p>
<p>Instead we’ll use references. These provide a way to give a value a
different name. For now, we can limit ourselves to so-called “lvalue
references”; there are other kinds, where the rules are different.</p>
<p>Enough. Let’s dive into a function and look at some examples.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Recall that void means the function will not return anything.</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reference_practice<span class="op">()</span> <span class="op">{</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// I&#39;ll step aside from my usual system of introducing practical examples</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// for now.  References are mostly used for parameters and return values,</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// but the basic mechanics are easier to demonstrate within one function.</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If we want to make another name for something, we need to have that</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// something first.  Let&#39;s use x for this example.</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The type &quot;reference to int&quot; is written as int&amp;.  We say that the</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// reference y is bound to x.  This can only be done when we define y; from</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this point onwards, y and x are going to behave the same way.</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Conversely, we have to bind y to something; an unbound reference would be</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// useless, and is thus forbidden.</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> y <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// (Later on, when we learn how to inspect the declared types of x and y,</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we&#39;ll be able to see a few differences.  Those aren&#39;t worth worrying</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// about yet; you can treat y and x as the same.)</span></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;int x = 5;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;int&amp; y = x;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  y == &quot;</span> <span class="op">&lt;&lt;</span> y <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Let&#39;s try assigning something to y:</span></span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;y = 2;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  y == &quot;</span> <span class="op">&lt;&lt;</span> y <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Let&#39;s assign something to x now:</span></span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;x = 3;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  y == &quot;</span> <span class="op">&lt;&lt;</span> y <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// No matter what we do, x and y will have the same value.</span></span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A reference to a reference doesn&#39;t make sense.  We can bind an int&amp; to y,</span></span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// but it will have the same effect as binding it to x.</span></span></code></pre></div>
<p>By the way, remember how I said that if you have a “simple type” like
int, you can define multiple variables in one line by separating them
with a comma? Well, C++ inherited certain rules from C, and those made
sense at the time… put simply, int&amp; is no longer simple enough for
this to be true. For example, had we said</p>
<p><code>int&amp; z1 = x, z2 = y;</code></p>
<p>only z1 would be a reference, and z2 would not be. If you want the
nitty gritty of it, there’s a great post on StackOverflow about it: *
https://stackoverflow.com/a/13808933/559931</p>
<p>appendix on how these rules work exactly; fortunately, we’ll soon see
a workaround that lets us turn any type into a “simple type”. For now,
when in doubt, write things out on their own line.</p>
<p>(As a bonus, you can define both an int&amp; and an int in a for loop
initialisation; don’t expect to make many friends that way, though.)</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Note also that auto assumes your variable shouldn&#39;t be a reference unless</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// you explicitly tell it otherwise:</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> z1 <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> z2 <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The compiler will auto-detect the type for z2, assuming that it has to be</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a reference type.  Such &quot;partial detection&quot; is only possible for a few</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// cases.</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;auto z1 = y;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;auto&amp; z2 = y;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;x = 8;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  z1 == &quot;</span> <span class="op">&lt;&lt;</span> z1 <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  z2 == &quot;</span> <span class="op">&lt;&lt;</span> z2 <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now let&#39;s look at how it works with functions.  By the way, we while can</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// declare functions inside other functions, we can&#39;t define them.</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> takes_a_reference<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> i<span class="op">);</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="co">// newline for readability.</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// takes_a_reference takes an int by reference.  No copy will be made</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// (though for an int, this is minor), and the value may change.</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;takes_a_reference(x);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    takes_a_reference<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Did x change? Until you look at the definition of takes_a_reference,
you can’t be sure. We know that sum, average, and filter_greater_than
shouldn’t be modifying the vectors we pass to them, though. In fact,
we’d like to be able to provide a guarantee for that.</p>
<p>C++ allows this to be done using const. Just like int, int const is a
type. It has all the same possible values that int has, but it doesn’t
allow any operations that modify the value of a variable. That means
that once we’ve defined it, we can’t ever change it again.</p>
<p>(Because of this, when working with const versions primitive types
like int, you have to initialise the value as soon as you define the
variable: there’s no point if you don’t!)</p>
<p>A little bit about reading types: the best approximation is to read
from right to left. An int const is a constant integer. An int&amp; is a
reference to an integer. An int const&amp; is a reference to a constant
integer.</p>
<p>Because every int can be treated as an int const without any
problems, we can make an int const&amp; refer to an int. This lets us
make a reference, which means we avoid a copy, but we don’t have to
worry about our value being changed.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is almost the same thing as our first example with y.  However,</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this name for x doesn&#39;t let x be modified, while y does.  You could see</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the difference as a drop in the amount of information: y knows that x is</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// actually mutable, this one doesn&#39;t.</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span><span class="op">&amp;</span> c <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;int const&amp; c = x;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Note that even though we can&#39;t change x via c, we can change c via x!</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  c == &quot;</span> <span class="op">&lt;&lt;</span> c <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;x = 5;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  c == &quot;</span> <span class="op">&lt;&lt;</span> c <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now let&#39;s see what it looks like when we&#39;re dealing with functions:</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> takes_a_reference_to_const<span class="op">(</span><span class="dt">int</span> <span class="at">const</span><span class="op">&amp;</span> i<span class="op">);</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>    takes_a_reference_to_const<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;takes_a_reference_to_const(x);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now we know that x did not change (unless someone has been doing some</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// very, very nasty things).</span></span></code></pre></div>
<p>What about an int&amp; const? That won’t work. It doesn’t make sense
for a reference to be constant: we already can’t change what it’s an
alias for, and whether we can change the value it refers to is
determined by the inner const. Because of this, int&amp; const is an
error.</p>
<p>Another good question is: what can we make references to? It turns
out that the answer is not all that simple.</p>
<p>First of all: if we have a named variable, we can always take a
reference to it. Furthermore, if a function returns a reference, we can
make a reference to it. Those are the two basic cases.</p>
<p>When dealing with references to const types, we have a little more
freedom: we can take a reference to const to just about anything that is
of the same type. If we take a reference to something that isn’t of the
same type but is convertible to it, a temporary will be created and you
will get a reference to that.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// That last part has some surprising implications that you have to keep in</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// mind.  On the one hand, it means we can do the following:</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> str<span class="op">);</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// What&#39;s the \&quot;?  We can&#39;t have a &quot; in the string, as that would end the</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// string.  The \&quot; is turned into a &quot;.</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;print(</span><span class="sc">\&quot;</span><span class="st">I&#39;m a string literal, not a string, but I can be converted!</span><span class="sc">\&quot;</span><span class="st">);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="st">&quot;I&#39;m a string literal, not a string, but I can be converted!&quot;</span><span class="op">);</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is extremely convenient and the intended use of this rule.  On the</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// other hand...</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;double const&amp; d = x;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="at">const</span><span class="op">&amp;</span> d <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  d == &quot;</span> <span class="op">&lt;&lt;</span> d <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">13</span><span class="op">;</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;x = 13;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  x == &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  d == &quot;</span> <span class="op">&lt;&lt;</span> d <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// here, d is not a reference to x!  A reference to a double, even if it is</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a double const, cannot reference an int!  Instead, a temporary was</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// created and d refers to that.</span></span></code></pre></div>
<p>This brings us to another very important issue. We saw in the last
chapter that temporaries don’t live very long. How come this was
okay?</p>
<p>When a reference is bound to a temporary, that temporary is rescued
from immenent doom and will live as long as the reference bound to it
does.</p>
<p>Note that this extension is only granted to temporaries. A reference
to non-const cannot be bound to a temporary, so it can never perform
such extension. Furthermore, binding a reference to a reference will not
extend the lifetime further. You cannot repeat this trick; trying to do
so will cause unpredictable and probably unpleasant results.</p>
<p>For a similar reason, returning references to values is something
that has to be done with some care. Had the return type of this function
been int&amp;, we could have said “return x;” and returned a reference
to x. However, x would be destroyed when we left the function and the
reference would not refer to anything meaningful. It’s roughly the same
situation as if we returned an iterator into a vector that we defined in
this function.</p>
<p>Note that lifetime extension cannot help here; it does not work for
return values.</p>
<p>As with iterators, be careful about taking references to things that
may outlive the reference. In particular, although returning references
is often very useful, make sure that it is also legal.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Some helper functions to illustrate the points above.  Play around with them</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">// to see what is and isn&#39;t allowed.</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> takes_a_reference<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  i == &quot;</span> <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;i = 7;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> takes_a_reference_to_const<span class="op">(</span><span class="dt">int</span> <span class="at">const</span><span class="op">&amp;</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  i == &quot;</span> <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> str<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;&gt;  str == </span><span class="sc">\&quot;</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> str <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\&quot;\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> str <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a><span class="co">// Now that we&#39;ve covered the theory, we can look at how it relates to our</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a><span class="co">// vector algorithms.</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;vector_algos.hpp&quot;</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Lets you see the results and experiment.</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>    reference_practice<span class="op">();</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="co">// a newline to make it easier on the eyes</span></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter as many numbers as you want:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> sort<span class="op">(</span>read_int_vector<span class="op">());</span></span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;You entered:&quot;</span><span class="op">;</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">;</span></span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Search for a few numbers amongst those the user entered.</span></span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">50</span><span class="op">;</span> i <span class="op">+=</span> <span class="dv">5</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> it <span class="op">=</span> binary_search<span class="op">(</span>v<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>it <span class="op">==</span> v<span class="op">.</span>end<span class="op">())</span></span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot; was not amongst the numbers you entered.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;You entered &quot;</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>it <span class="op">-</span> v<span class="op">.</span>begin<span class="op">())</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; numbers less than &quot;</span> <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Average: &quot;</span> <span class="op">&lt;&lt;</span> average<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Sum: &quot;</span> <span class="op">&lt;&lt;</span> sum<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-50"><a href="#cb35-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Elements greater than 5:&quot;</span><span class="op">;</span></span>
<span id="cb35-51"><a href="#cb35-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> filter_greater_than<span class="op">(</span>v<span class="op">,</span> <span class="dv">5</span><span class="op">))</span></span>
<span id="cb35-52"><a href="#cb35-52" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">;</span></span>
<span id="cb35-53"><a href="#cb35-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb35-54"><a href="#cb35-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="vector_algos.cpp-2">vector_algos.cpp</h2>
<div class="sourceCode" id="cb36"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;vector_algos.hpp&quot;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Note that we shouldn&#39;t repeat the default value here; we already know it from</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">// the header!</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Seeing as we can&#39;t rely on the user being present any more, let&#39;s drop most</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co">// of the output statements.  The ones we keep shouldn&#39;t go to std::cout any</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="co">// more; C++ provides a stream std::cerr that we can use the same way we used</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="co">// std::cout, but that is intended for errors.  We&#39;ll use that for reporting</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="co">// what characters we ignored.</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> read_int_vector<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>stream <span class="op">&gt;&gt;</span> x<span class="op">)</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>stream<span class="op">.</span>eof<span class="op">())</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>getline<span class="op">(</span>stream<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Warning, ignoring: &quot;</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> e<span class="op">;</span></span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_greater_than<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>e <span class="op">&gt;</span> x<span class="op">)</span></span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span>e<span class="op">);</span></span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-50"><a href="#cb36-50" aria-hidden="true" tabindex="-1"></a><span class="co">// We move the declarations out now that they&#39;re no longer a surprise.</span></span>
<span id="cb36-51"><a href="#cb36-51" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> iterator <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>iterator<span class="op">;</span></span>
<span id="cb36-52"><a href="#cb36-52" aria-hidden="true" tabindex="-1"></a>iterator partition<span class="op">(</span>iterator begin<span class="op">,</span> iterator end<span class="op">);</span></span>
<span id="cb36-53"><a href="#cb36-53" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sort_impl<span class="op">(</span>iterator begin<span class="op">,</span> iterator end<span class="op">);</span></span>
<span id="cb36-54"><a href="#cb36-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-55"><a href="#cb36-55" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> sort<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-56"><a href="#cb36-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-57"><a href="#cb36-57" aria-hidden="true" tabindex="-1"></a>    sort_impl<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb36-58"><a href="#cb36-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v<span class="op">;</span></span>
<span id="cb36-59"><a href="#cb36-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb36-60"><a href="#cb36-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-61"><a href="#cb36-61" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sort_impl<span class="op">(</span>iterator begin<span class="op">,</span> iterator end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-62"><a href="#cb36-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>end <span class="op">-</span> begin <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb36-63"><a href="#cb36-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb36-64"><a href="#cb36-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-65"><a href="#cb36-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pivot <span class="op">=</span> partition<span class="op">(</span>begin<span class="op">,</span> end<span class="op">);</span></span>
<span id="cb36-66"><a href="#cb36-66" aria-hidden="true" tabindex="-1"></a>    sort_impl<span class="op">(</span>begin<span class="op">,</span> pivot<span class="op">);</span></span>
<span id="cb36-67"><a href="#cb36-67" aria-hidden="true" tabindex="-1"></a>    sort_impl<span class="op">(</span>pivot<span class="op">+</span><span class="dv">1</span><span class="op">,</span> end<span class="op">);</span></span>
<span id="cb36-68"><a href="#cb36-68" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb36-69"><a href="#cb36-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-70"><a href="#cb36-70" aria-hidden="true" tabindex="-1"></a>iterator partition<span class="op">(</span>iterator begin<span class="op">,</span> iterator end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-71"><a href="#cb36-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pivot <span class="op">=</span> begin<span class="op">++;</span></span>
<span id="cb36-72"><a href="#cb36-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-73"><a href="#cb36-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(;</span> begin <span class="op">!=</span> end<span class="op">;</span> <span class="op">++</span>begin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-74"><a href="#cb36-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*</span>pivot <span class="op">&gt;</span> <span class="op">*</span>begin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-75"><a href="#cb36-75" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>swap<span class="op">(*</span>pivot<span class="op">,</span> <span class="op">*</span>begin<span class="op">);</span></span>
<span id="cb36-76"><a href="#cb36-76" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span>pivot<span class="op">;</span></span>
<span id="cb36-77"><a href="#cb36-77" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>swap<span class="op">(*</span>pivot<span class="op">,</span> <span class="op">*</span>begin<span class="op">);</span></span>
<span id="cb36-78"><a href="#cb36-78" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb36-79"><a href="#cb36-79" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-80"><a href="#cb36-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-81"><a href="#cb36-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pivot<span class="op">;</span></span>
<span id="cb36-82"><a href="#cb36-82" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb36-83"><a href="#cb36-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-84"><a href="#cb36-84" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator binary_search<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">,</span> <span class="dt">int</span> val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-85"><a href="#cb36-85" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> bottom <span class="op">=</span> v<span class="op">.</span>begin<span class="op">(),</span> top <span class="op">=</span> v<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb36-86"><a href="#cb36-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-87"><a href="#cb36-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>top <span class="op">!=</span> bottom<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-88"><a href="#cb36-88" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> mid <span class="op">=</span> bottom <span class="op">+</span> <span class="op">(</span>top <span class="op">-</span> bottom<span class="op">)/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb36-89"><a href="#cb36-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*</span>mid <span class="op">&lt;</span> val<span class="op">)</span></span>
<span id="cb36-90"><a href="#cb36-90" aria-hidden="true" tabindex="-1"></a>            bottom <span class="op">=</span> mid<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb36-91"><a href="#cb36-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(*</span>mid <span class="op">&gt;</span> val<span class="op">)</span></span>
<span id="cb36-92"><a href="#cb36-92" aria-hidden="true" tabindex="-1"></a>            top <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb36-93"><a href="#cb36-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb36-94"><a href="#cb36-94" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mid<span class="op">;</span></span>
<span id="cb36-95"><a href="#cb36-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-96"><a href="#cb36-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-97"><a href="#cb36-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb36-98"><a href="#cb36-98" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="vector_algos.hpp-2">vector_algos.hpp</h2>
<div class="sourceCode" id="cb37"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_10_VECTOR_ALGOS_HPP</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_10_VECTOR_ALGOS_HPP</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="co">// All we have to do here is replace std::vector&lt;int&gt; with std::vector&lt;int&gt;</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="co">// const&amp; in the parameter lists.</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Now that we can pass references, we can tell read_int_vector where to read</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="co">// the data from.  Instead of always reading from std::cin, let&#39;s make std::cin</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="co">// the default and allow the caller to pass an alternative if they want.</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="co">// The type of std::cin is std::istream.  We want a reference to that; we&#39;ll be</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="co">// extracting things from the stream, so it can&#39;t be a reference to const.  That</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="co">// means the type should be std::istream&amp;.  In order to give it a default value</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="co">// we say type param_name = default_value.</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> read_int_vector<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream <span class="op">=</span> <span class="bu">std::</span>cin<span class="op">);</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">);</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a><span class="co">// Note that we don&#39;t change the return value to std::vector&lt;int&gt; const&amp;.  Why</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a><span class="co">// not?  Do not continue to the next chapter until you are comfortable with the</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a><span class="co">// answer; this is fundamental understanding that cannot be skipped over.</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_greater_than<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">,</span> <span class="dt">int</span> x<span class="op">);</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> average<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now that we&#39;ve seen how to create a variable of a certain type on the</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// fly, we could use int{v.size()} to turn v.size() into an int.  However,</span></span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this would be a narrowing conversion, as we&#39;re losing part of the data.</span></span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We know that if a collection has more elements than the maximum value of</span></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// an int, we won&#39;t be getting any kind of meaningful average anyway, so we</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// don&#39;t mind that.</span></span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// To tell the compiler that this really is what we want, we use the older</span></span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and less strict int(v.size()), which does allow such unsafe conversions.</span></span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Be careful with int()!  There are things it can do that you definitely</span></span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// don&#39;t want.  Don&#39;t use it unless you know that int{} won&#39;t do, and you&#39;ve</span></span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// checked that it really does what you expect it to.</span></span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We&#39;ll see some safer ways to do even what we&#39;re doing now, but I&#39;d like</span></span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to leave that bag of tricks for another day.</span></span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum<span class="op">(</span>v<span class="op">)/</span><span class="dt">int</span><span class="op">(</span>v<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a><span class="co">// We&#39;re not going to change the type of sort.  We need to perform a copy of the</span></span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a><span class="co">// vector anyway; we may as well do that when the vector is passed in -- there</span></span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a><span class="co">// are cases where this is faster than doing it later.</span></span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> sort<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">);</span></span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a><span class="co">// On the other hand, now that we are taking a reference to a vector here, we</span></span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a><span class="co">// can return an iterator.  The vector we are searching is the one that is in</span></span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a><span class="co">// the function calling us, so the iterator can still be valid after we return</span></span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a><span class="co">// it.</span></span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a><span class="co">// Instead of returning an std::vector&lt;int&gt;::iterator, we return an</span></span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a><span class="co">// std::vector&lt;int&gt;::const_iterator.  This is also an iterator, but it doesn&#39;t</span></span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a><span class="co">// allow us to modify the values it refers to.</span></span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator binary_search<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">,</span> <span class="dt">int</span> val<span class="op">);</span></span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-11---standard-algorithms">Chapter 11 - Standard
Algorithms</h1>
<h2 id="main.cpp-11">main.cpp</h2>
<p>We’ve already used functions in a number of different ways. We were
able to get rid of some code duplication by using a function in several
different places; we were also able to make our code clearer by moving
parts out into functions of their own, and only having to mention their
name.</p>
<p>Now we will look at another benefit functions can have: they make it
easy for us to use code others have written. As an example, we’re going
to rewrite our sum function to use a standard functions. We’re also
going to write a few new functions.</p>
<p>Before we get to that, though, there’s a number of standard
algorithms that we can use directly from main.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;vector_algos.hpp&quot;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Let&#39;s define an alternative rule for comparing ints.  Instead of comparing</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="co">// them directly, we&#39;ll compare their values squared.  custom_comparison will</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="co">// return true for all x which are strictly less than y according to these</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="co">// rules.</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> custom_comparison<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>x <span class="op">&lt;</span> y<span class="op">*</span>y<span class="op">;</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter at least one number:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> read_int_vector<span class="op">();</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We don&#39;t want to have to write special cases for empty everywhere, so</span></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// let&#39;s terminate the program if that happens.</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;I said, at least one number.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::max_element takes an iterator range and returns an iterator to the</span></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// greatest element.  Note that we can dereference the iterator safely here;</span></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// why?  How long will what it points to exist for?</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum element: &quot;</span> <span class="op">&lt;&lt;</span> <span class="op">*</span><span class="bu">std::</span>max_element<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">())</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Minimum element is similar.  However, let&#39;s use our custom comparison</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// function.  Both max_element and min_element allow us to pass it as a</span></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// third argument.  If we don&#39;t, they assume we want comparison using the &lt;</span></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// operator.</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Minimum element (normal): &quot;</span></span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span> <span class="op">*</span><span class="bu">std::</span>min_element<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">())</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Minimum element (custom comparison): &quot;</span></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span> <span class="op">*</span><span class="bu">std::</span>min_element<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> custom_comparison<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Sum: &quot;</span> <span class="op">&lt;&lt;</span> sum<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Average: &quot;</span> <span class="op">&lt;&lt;</span> average<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>all_positive<span class="op">(</span>v<span class="op">))</span></span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;All numbers you entered were positive.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;You entered at least one negative number or zero.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We don&#39;t have to write our own sort function: the standard provides one</span></span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// for us.</span></span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The sort is in-place, though, so we lost the original order of v.</span></span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Let&#39;s add a function that lets us display a range.</span></span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Your input, sorted: &quot;</span><span class="op">;</span></span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a>    display_range<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::sort also takes a custom comparison function.  Let&#39;s see how our</span></span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">// input looks sorted that way:</span></span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> custom_comparison<span class="op">);</span></span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Your input, sorted using a custom comparison function: &quot;</span><span class="op">;</span></span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a>    display_range<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb38-65"><a href="#cb38-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb38-66"><a href="#cb38-66" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="vector_algos.cpp-3">vector_algos.cpp</h2>
<div class="sourceCode" id="cb39"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;vector_algos.hpp&quot;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> read_int_vector<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Instead of using a loop here, we can use std::copy.</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// This may be a little surprising: after all, std::istream doesn&#39;t look</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// like a collection, how could it have begin and end iterators?  What</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// would it mean to add a number to the iterator; would we be skipping</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// some inputs?  Would subtracting a number mean we go back to earlier</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// inputs?</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">//</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The answer is that unlike vector iterators, std::istream iterators aren&#39;t</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// random access.  You can still do a few of the things we could do with</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// vector iterators, but nowhere near as many.  In fact, std::istream</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// iterators are input iterators: that&#39;s the most limited family of</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// iterators available.  You can only increment them, read from them,</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// and compare them for equality.  For copying, we don&#39;t need any more.</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">//</span></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We will be using the type std::istream_iterator&lt;int&gt;.  If we want to</span></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// create a temporary object of a type, we can use the type followed by</span></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// a pair of curly braces.  Within these curly braces we can give</span></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// arguments for how the temporary should be constructed.  For example,</span></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// std::vector&lt;int&gt;{1, 2, 3} would create a vector containing the ints</span></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 1, 2, and 3.  We can do a similar thing for std::istream iterators,</span></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// where we pass a stream, and get the current iterator for that stream.</span></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If we don&#39;t pass anything, we get an end iterator that works for any</span></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// stream.</span></span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">//</span></span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Thus, our begin iterator is std::istream_iterator&lt;int&gt;{stream}, while</span></span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// our end iterator is std::istream_iterator&lt;int&gt;{}.</span></span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">//</span></span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Where do we copy to?  We can&#39;t copy to result.begin(), because there</span></span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">// won&#39;t be enough room there.  Instead, the standard library provides</span></span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// us with std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt;.  That&#39;s a</span></span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// mouthful, but we can make one with std::back_inserter(result).</span></span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">//</span></span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// All in all, we get:</span></span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>copy<span class="op">(</span><span class="bu">std::</span>istream_iterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span>stream<span class="op">},</span> <span class="bu">std::</span>istream_iterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{},</span></span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>back_inserter<span class="op">(</span>result<span class="op">));</span></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>        <span class="co">// This may seem like a mouthful, but it&#39;s a good idea to understand it;</span></span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">// iterators provide a powerful abstraction over much more than simple,</span></span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">// linear containers like vector.</span></span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>stream<span class="op">.</span>eof<span class="op">())</span></span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-58"><a href="#cb39-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb39-59"><a href="#cb39-59" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>getline<span class="op">(</span>stream<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb39-60"><a href="#cb39-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-61"><a href="#cb39-61" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Warning, ignoring: &quot;</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb39-62"><a href="#cb39-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-63"><a href="#cb39-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-64"><a href="#cb39-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb39-65"><a href="#cb39-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-66"><a href="#cb39-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-67"><a href="#cb39-67" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-68"><a href="#cb39-68" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We use std::accumulate.  It takes a range and an initial value, and then</span></span>
<span id="cb39-69"><a href="#cb39-69" aria-hidden="true" tabindex="-1"></a>    <span class="co">// uses the + operator to add all the values together.  There&#39;s another</span></span>
<span id="cb39-70"><a href="#cb39-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">// version which also takes a function to use instead of the + operator, but</span></span>
<span id="cb39-71"><a href="#cb39-71" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we don&#39;t need that here.</span></span>
<span id="cb39-72"><a href="#cb39-72" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb39-73"><a href="#cb39-73" aria-hidden="true" tabindex="-1"></a>    <span class="co">// begin, end, and initial value 0.  Tada!  And don&#39;t worry - chances are</span></span>
<span id="cb39-74"><a href="#cb39-74" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that this is as efficient as writing out the loop.</span></span>
<span id="cb39-75"><a href="#cb39-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>accumulate<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb39-76"><a href="#cb39-76" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-77"><a href="#cb39-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-78"><a href="#cb39-78" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_greater_than<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-79"><a href="#cb39-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">// While there is an std::copy_if that we could use to implement this</span></span>
<span id="cb39-80"><a href="#cb39-80" aria-hidden="true" tabindex="-1"></a>    <span class="co">// function, we currently don&#39;t have the tools to turn x into a function</span></span>
<span id="cb39-81"><a href="#cb39-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that returns true for values greater than x, and false for all other</span></span>
<span id="cb39-82"><a href="#cb39-82" aria-hidden="true" tabindex="-1"></a>    <span class="co">// values.  We&#39;ll see how to do it soon enough, though!</span></span>
<span id="cb39-83"><a href="#cb39-83" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb39-84"><a href="#cb39-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb39-85"><a href="#cb39-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>e <span class="op">&gt;</span> x<span class="op">)</span></span>
<span id="cb39-86"><a href="#cb39-86" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span>e<span class="op">);</span></span>
<span id="cb39-87"><a href="#cb39-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb39-88"><a href="#cb39-88" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-89"><a href="#cb39-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-90"><a href="#cb39-90" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> is_positive<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-91"><a href="#cb39-91" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-92"><a href="#cb39-92" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-93"><a href="#cb39-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-94"><a href="#cb39-94" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> all_positive<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-95"><a href="#cb39-95" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is a very straightforward use of std::all_of.  It takes a range and</span></span>
<span id="cb39-96"><a href="#cb39-96" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a predicate -- a function taking some values and returning bool -- and</span></span>
<span id="cb39-97"><a href="#cb39-97" aria-hidden="true" tabindex="-1"></a>    <span class="co">// then returns true if the predicate returns true for all values in the</span></span>
<span id="cb39-98"><a href="#cb39-98" aria-hidden="true" tabindex="-1"></a>    <span class="co">// range.  If the range is empty, it also returns true; this is a nicer</span></span>
<span id="cb39-99"><a href="#cb39-99" aria-hidden="true" tabindex="-1"></a>    <span class="co">// generalisation than if the empty range resulted in false.  (For instance,</span></span>
<span id="cb39-100"><a href="#cb39-100" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it means that every subrange of a range that returns true will also</span></span>
<span id="cb39-101"><a href="#cb39-101" aria-hidden="true" tabindex="-1"></a>    <span class="co">// return true.)</span></span>
<span id="cb39-102"><a href="#cb39-102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>all_of<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> is_positive<span class="op">);</span></span>
<span id="cb39-103"><a href="#cb39-103" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-104"><a href="#cb39-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-105"><a href="#cb39-105" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> display_range<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator begin<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-106"><a href="#cb39-106" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Let&#39;s surround the output with nice curly braces.</span></span>
<span id="cb39-107"><a href="#cb39-107" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;{ &quot;</span><span class="op">;</span></span>
<span id="cb39-108"><a href="#cb39-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-109"><a href="#cb39-109" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The way to print things with iterators is much the same to how one reads</span></span>
<span id="cb39-110"><a href="#cb39-110" aria-hidden="true" tabindex="-1"></a>    <span class="co">// things with them.  We use an std::ostream_iterator&lt;int&gt;, which we give a</span></span>
<span id="cb39-111"><a href="#cb39-111" aria-hidden="true" tabindex="-1"></a>    <span class="co">// stream to write to and a bit of text to print after each value.</span></span>
<span id="cb39-112"><a href="#cb39-112" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb39-113"><a href="#cb39-113" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::ostream_iterators are output iterators.  They support all the</span></span>
<span id="cb39-114"><a href="#cb39-114" aria-hidden="true" tabindex="-1"></a>    <span class="co">// operations of input iterators, except that you cannot read from them; you</span></span>
<span id="cb39-115"><a href="#cb39-115" aria-hidden="true" tabindex="-1"></a>    <span class="co">// can, however, write to them, and whatever you write will be printed.  You</span></span>
<span id="cb39-116"><a href="#cb39-116" aria-hidden="true" tabindex="-1"></a>    <span class="co">// should increment them between each write.</span></span>
<span id="cb39-117"><a href="#cb39-117" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>copy<span class="op">(</span>begin<span class="op">,</span> end<span class="op">,</span> <span class="bu">std::</span>ostream_iterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="bu">std::</span>cout<span class="op">,</span> <span class="st">&quot; &quot;</span><span class="op">});</span></span>
<span id="cb39-118"><a href="#cb39-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-119"><a href="#cb39-119" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;}&quot;</span><span class="op">;</span></span></code></pre></div>
<p>By the way, have you noticed that even though copy works on two
ranges, we only need to pass the end iterator of the one we’re copying
from? That’s because the standard library assumes that the other will be
long enough. If that’s not the case, unpredictable and almost certainly
unpleasant things will happen. (Unpredictable and unpleasant things
happening is a common thing in C++ if you’re not careful; there’ll be a
chapter on it later.)</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice how we’re mentioning the fact that we’re operating on vectors
of ints everywhere. However, if we wanted to write these algorithms for
a vector of doubles, the code would likely be much the same. In the next
chapter we’ll take a look at how we can make these functions work on a
vector of any type that supports the right operations. Our sum function
will even be able to take the sum of a vector of strings!</p>
<h2 id="vector_algos.hpp-3">vector_algos.hpp</h2>
<div class="sourceCode" id="cb41"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_11_VECTOR_ALGOS</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_11_VECTOR_ALGOS</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> read_int_vector<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream <span class="op">=</span> <span class="bu">std::</span>cin<span class="op">);</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">);</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_greater_than<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">,</span> <span class="dt">int</span> x<span class="op">);</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> average<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum<span class="op">(</span>v<span class="op">)/</span><span class="dt">int</span><span class="op">(</span>v<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> all_positive<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">);</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> display_range<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator begin<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator end<span class="op">);</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-12---function-templates">Chapter 12 - Function
Templates</h1>
<h2 id="main.cpp-12">main.cpp</h2>
<p>Suggested order: main.cpp (beginning), vector_algos.hpp, main.cpp
(end)</p>
<p>In this chapter we’ll take a look at templates. We won’t cover them
entirely right away; templates have some very advanced features that we
don’t currently have a use for. However, the basic uses are already
applicable, and so we’ll take a brief look at those.</p>
<p>Functions allow us to generalise code over values; templates allow us
to generalise code over types.</p>
<p>In the last few chapters we wrote many functions that worked on
vectors of ints. We’ll now use templates to allow us to work over many
types.</p>
<p>By the way, even though we are only now writing our own templates,
we’ve already used many that the standard library has provided us with.
The only explicit use was std::vector, where we could provide the type
of the elements we’d like to store. We could use std::vector&lt;int&gt;,
or std::vector&lt;double&gt;, or even
std::vector&lt;std::vector&lt;std::string&gt;&gt;, while the programmers
of the standard library only had to write std::vector once.</p>
<p>(In practice, they may have written specialised options to improve
performance in some cases. There is also std::vector&lt;bool&gt;, which
the standard insists be a little different.)</p>
<p>Apart from that, all of the standard algorithms we used in the last
chapter were actually templates. We could pretend they were just
functions because the compiler could figure out what types we wanted to
use them on from the arguments we passed. We’ll keep using that feature
in this chapter, though there’ll be a few places we have to explicitly
specify the types anyway.</p>
<p>Take a look at vector_algos.hpp now, and come back to look at main
once you’ve seen how templates are implemented.</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;vector_algos.hpp&quot;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Welcome back.  As you can see, our main function is almost undisturbed,</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// except that we have read_vector&lt;int&gt; instead of read_int_vector.  Does</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the program still work if you change int to double?  What about to</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::string?</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter at least one number:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> read_vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;();</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;I said, at least one number.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Sum: &quot;</span> <span class="op">&lt;&lt;</span> sum<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Average: &quot;</span> <span class="op">&lt;&lt;</span> average<span class="op">(</span>v<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sorted_v <span class="op">=</span> sort<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Let&#39;s add a function that lets us display a range.</span></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Your input, sorted: &quot;</span><span class="op">;</span></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>    display_range<span class="op">(</span>sorted_v<span class="op">.</span>begin<span class="op">(),</span> sorted_v<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>That’s all we’ll cover about templates for now. There is much, much
more to see, but it isn’t relevant yet. The next chapter is going to be
about handling errors.</p>
<p>The next big topic is going to be classes, and that’s going to take
quite a few chapters. I find that covering classes in isolation makes it
hard to grasp why you’d use them. Starting from the lesson after next,
we’ll be working on building a larger program, where we’ll be applying a
mix of everything we’ve learned so far.</p>
<h2 id="vector_algos.hpp-4">vector_algos.hpp</h2>
<div class="sourceCode" id="cb43"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_12_VECTOR_ALGOS_HPP</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_12_VECTOR_ALGOS_HPP</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span></code></pre></div>
<p>A template of a function allows us to write a function and then
specify some of the types later. When we specify the types, a specific
instantiation of the template will be created, with the blanks for the
types filled in. Note that a template of a function is not itself a
function: it is a recipe for creating a function.</p>
<p>Because of this, you can’t simply declare the template in a header
and then define it in a source file. If we tried, the compiler wouldn’t
know how to create an instantiation for a specific type, and would
assume that it has been explicitly created elsewhere. This can work
sometimes, but the “normal” way is to define templates in headers.</p>
<p>How do we define a function template, anyway? We start out be
specifying how many types we’re generalising over; listing the
parameters of the template, just like we’d normally list the parameters
of the function:</p>
<p><code>template&lt;typename T1, typename T2...&gt;</code></p>
<p>After we’ve written that, we write a function as normal. However, we
can use T1 and T2 from above as types. As a very simple example, we may
write</p>
<p><code>template&lt;typename NUM&gt;</code></p>
<p><code>NUM add(NUM x, NUM y, NUM z) {</code></p>
<p><code>return x + y + z;</code></p>
<p><code>}</code></p>
<p>When we want to call our function template, we provide the type
arguments to the template between &lt; and &gt; angle braces, just like
we did with std::vector. If we want to use add with NUM being int, we
say:</p>
<p><code>add&lt;int&gt;(5, 6, 7)</code></p>
<p>The resulting code will probably be (almost) the same as if we
wrote</p>
<p><code>int add_int(int x, int y, int z) {</code></p>
<p><code>return x + y + z;</code></p>
<p><code>}</code></p>
<p>and then called add_int(5, 6, 7). However, the template version lets
us say</p>
<p><code>add&lt;double&gt;(2.71, 3.14, 9.9)</code></p>
<p>and even (adding two std::strings concatenates them)</p>
<p><code>add&lt;std::string&gt;("Hello ", "World", "!")</code></p>
<p>Notice that in add&lt;int&gt;(5, 6, 7) all parameters have type int.
This lets the compiler guess that we want to use the int version, and so
we can simply call</p>
<p><code>add(5, 6, 7)</code></p>
<p>and the template arguments will be deduced. The same works for the
double example. Unfortunately, it breaks down in the last example:
string literals aren’t of type std::string, so the deduction would not
be correct.</p>
<p>Let’s take a look at how our functions look when rewritten to
function templates.</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">// T is a very common name to use for template parameters.  Here, we still want</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co">// to read an std::vector, but we want to allow vectors of types other than int.</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="co">// We use a single parameter to take the place of int, and then replace all</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="co">// int-specific code with code that works with T.  When we use read_vector&lt;int&gt;,</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="co">// the int will be filled back in and we&#39;ll get our old function back.</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> read_vector<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream <span class="op">=</span> <span class="bu">std::</span>cin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The function&#39;s return type and the type of result need slight changes.</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We want to copy whatever T is, now, not specifically int.</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>copy<span class="op">(</span><span class="bu">std::</span>istream_iterator<span class="op">&lt;</span>T<span class="op">&gt;{</span>stream<span class="op">},</span> <span class="bu">std::</span>istream_iterator<span class="op">&lt;</span>T<span class="op">&gt;{},</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>back_inserter<span class="op">(</span>result<span class="op">));</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The rest of the function&#39;s code doesn&#39;t care whether we&#39;re working</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// with int or not, so we leave it as it was.</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>stream<span class="op">.</span>eof<span class="op">())</span></span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>getline<span class="op">(</span>stream<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Warning, ignoring: &quot;</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Above, we said we could pass the template parameters “later”. How
much later? Templates are a compile-time feature of C++. All types still
have to be known when you compile the code, so “later” here means “later
in the program text”.</p>
<p>By the time the program has been compiled, most of the types you
could see in the source code are gone. We will see some ways of working
with types at run-time, but those are the exception, not the rule.
Templates are the same way; once your program is compiled, they’re gone,
and only their instantiations remain.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">// We do a similar thing here.</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>T sum<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We could use 0 as the starting value and assume that 0 can be converted</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to a T.  However, a better solution is to use T{}, which constructs a T</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// with no parameters.  For int, that&#39;s a 0; for double, it&#39;s 0.0; for bool,</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it&#39;s false; for std::string, it&#39;s the empty string.</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Note that because of this, sum will work on std::strings!</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>accumulate<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> T<span class="op">{});</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// By the way, std::accumulate is itself a template.  We could explicitly</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// specify the template arguments:</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      std::accumulate&lt;std::vector&lt;T&gt;::const_iterator, T&gt;(</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">//          v.begin(), v.end(), T{});</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sometimes the compiler is not smart enough to figure it out, so we have</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to explicitly do this; however, as you can see, it doesn&#39;t look</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// particularly good.</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>By the way, what if we pass the template a type that doesn’t make any
sense? For example, what if we try to call sum&lt;void&gt;? Seeing as
templates are done compile-time, the compiler can detect errors like
this and give you an error. In this case, it may complain that we’re
passing void{} to a function, or that std::vector&lt;void&gt; isn’t
allowed. These errors are sometimes long and unclear; learning to read
them is part of learning C++.</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// In the original function, we took int x by value.  However, now that we may</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">// be dealing with arbitrary T, the copy may be expensive, so we take it by</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co">// const reference.</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> filter_greater_than<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">,</span> T <span class="at">const</span><span class="op">&amp;</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Notice how auto here means we have one less thing to change.</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> v<span class="op">)</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>e <span class="op">&gt;</span> x<span class="op">)</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span>e<span class="op">);</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>T average<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> T<span class="op">{};</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// At the moment, we don&#39;t enough about the language to be sure T(v.size())</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// is safe.  On the other hand, we also don&#39;t know any examples where it&#39;s</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// dangerous.  I know this&#39;ll be okay, but don&#39;t fall into the trap of this</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// being &quot;obviously right&quot;!</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum<span class="op">(</span>v<span class="op">)/</span>T<span class="op">(</span>v<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> is_positive<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">&gt;</span> T<span class="op">{};</span></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-30"><a href="#cb46-30" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb46-31"><a href="#cb46-31" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> all_positive<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-32"><a href="#cb46-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can specify template arguments even if we don&#39;t immediately call the</span></span>
<span id="cb46-33"><a href="#cb46-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// function and just pass it along.  If we were to not specify it, we&#39;d get</span></span>
<span id="cb46-34"><a href="#cb46-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// an error about the compiler not knowing which one to use.</span></span>
<span id="cb46-35"><a href="#cb46-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>all_of<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> is_positive<span class="op">&lt;</span>T<span class="op">&gt;);</span></span>
<span id="cb46-36"><a href="#cb46-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-37"><a href="#cb46-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-38"><a href="#cb46-38" aria-hidden="true" tabindex="-1"></a><span class="co">// Instead of generalising int and taking std::vector&lt;T&gt;::const_iterator, let&#39;s</span></span>
<span id="cb46-39"><a href="#cb46-39" aria-hidden="true" tabindex="-1"></a><span class="co">// allow any kind of iterator.  std::copy requires an input iterator to read</span></span>
<span id="cb46-40"><a href="#cb46-40" aria-hidden="true" tabindex="-1"></a><span class="co">// from, so we&#39;ll call the type parameter InputIt; this is fairly common.  This</span></span>
<span id="cb46-41"><a href="#cb46-41" aria-hidden="true" tabindex="-1"></a><span class="co">// is purely for people reading our code; the compiler doesn&#39;t care what we call</span></span>
<span id="cb46-42"><a href="#cb46-42" aria-hidden="true" tabindex="-1"></a><span class="co">// it.</span></span>
<span id="cb46-43"><a href="#cb46-43" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> InputIt<span class="op">&gt;</span></span>
<span id="cb46-44"><a href="#cb46-44" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> display_range<span class="op">(</span>InputIt begin<span class="op">,</span> InputIt end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-45"><a href="#cb46-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;{ &quot;</span><span class="op">;</span></span>
<span id="cb46-46"><a href="#cb46-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-47"><a href="#cb46-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// However, we&#39;re now faced with a bit of a problem: how do we specify the</span></span>
<span id="cb46-48"><a href="#cb46-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// type that std::ostream_iterator should output?  Had we generalised only</span></span>
<span id="cb46-49"><a href="#cb46-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// over int, that would have been T, but now we need to extract the type of</span></span>
<span id="cb46-50"><a href="#cb46-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the iterator&#39;s value.</span></span>
<span id="cb46-51"><a href="#cb46-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb46-52"><a href="#cb46-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fortunately, the designers of the standard library had anticipated this,</span></span>
<span id="cb46-53"><a href="#cb46-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and so there&#39;s a type</span></span>
<span id="cb46-54"><a href="#cb46-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb46-55"><a href="#cb46-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      std::vector&lt;int&gt;::const_iterator::value_type</span></span>
<span id="cb46-56"><a href="#cb46-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb46-57"><a href="#cb46-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// which is another name for int.  (More generally, if we switch int to T in</span></span>
<span id="cb46-58"><a href="#cb46-58" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the above, it&#39;ll be another name for T.)  This is not very useful by</span></span>
<span id="cb46-59"><a href="#cb46-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">// itself, but if InputIt is another name for</span></span>
<span id="cb46-60"><a href="#cb46-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::vector&lt;int&gt;::const_iterator, then we can use InputIt::value_type to</span></span>
<span id="cb46-61"><a href="#cb46-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">// get at that type!</span></span>
<span id="cb46-62"><a href="#cb46-62" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb46-63"><a href="#cb46-63" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The above is almost true.  We say that a type is a dependent type when it</span></span>
<span id="cb46-64"><a href="#cb46-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">// depends on a template parameter.  InputIt is a template parameter itself,</span></span>
<span id="cb46-65"><a href="#cb46-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and so is trivially a dependent type.  That means that</span></span>
<span id="cb46-66"><a href="#cb46-66" aria-hidden="true" tabindex="-1"></a>    <span class="co">// InputIt::value_type could be either a value or a type.  C++ compilers are</span></span>
<span id="cb46-67"><a href="#cb46-67" aria-hidden="true" tabindex="-1"></a>    <span class="co">// only human and have a hard time figuring this out themselves; because of</span></span>
<span id="cb46-68"><a href="#cb46-68" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that, we have to write typename before InputIt::value_type to indicate</span></span>
<span id="cb46-69"><a href="#cb46-69" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that it is, in fact, a type.</span></span>
<span id="cb46-70"><a href="#cb46-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb46-71"><a href="#cb46-71" aria-hidden="true" tabindex="-1"></a>    <span class="co">// For clarity, let&#39;s do it in two steps, first making a local name for the</span></span>
<span id="cb46-72"><a href="#cb46-72" aria-hidden="true" tabindex="-1"></a>    <span class="co">// type:</span></span>
<span id="cb46-73"><a href="#cb46-73" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T <span class="op">=</span> <span class="kw">typename</span> InputIt<span class="op">::</span><span class="dt">value_type</span><span class="op">;</span></span>
<span id="cb46-74"><a href="#cb46-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-75"><a href="#cb46-75" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now that we have extracted the value type, we can use it normally as a</span></span>
<span id="cb46-76"><a href="#cb46-76" aria-hidden="true" tabindex="-1"></a>    <span class="co">// type.</span></span>
<span id="cb46-77"><a href="#cb46-77" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>copy<span class="op">(</span>begin<span class="op">,</span> end<span class="op">,</span> <span class="bu">std::</span>ostream_iterator<span class="op">&lt;</span>T<span class="op">&gt;{</span><span class="bu">std::</span>cout<span class="op">,</span> <span class="st">&quot; &quot;</span><span class="op">});</span></span>
<span id="cb46-78"><a href="#cb46-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-79"><a href="#cb46-79" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;}&quot;</span><span class="op">;</span></span>
<span id="cb46-80"><a href="#cb46-80" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-81"><a href="#cb46-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-82"><a href="#cb46-82" aria-hidden="true" tabindex="-1"></a><span class="co">// We can generalise all the sort-related functions now.  They all use random</span></span>
<span id="cb46-83"><a href="#cb46-83" aria-hidden="true" tabindex="-1"></a><span class="co">// access iterators, so let&#39;s call them RandomIt.</span></span>
<span id="cb46-84"><a href="#cb46-84" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> RandomIt<span class="op">&gt;</span></span>
<span id="cb46-85"><a href="#cb46-85" aria-hidden="true" tabindex="-1"></a>RandomIt partition<span class="op">(</span>RandomIt begin<span class="op">,</span> RandomIt end<span class="op">);</span></span>
<span id="cb46-86"><a href="#cb46-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-87"><a href="#cb46-87" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> RandomIt<span class="op">&gt;</span></span>
<span id="cb46-88"><a href="#cb46-88" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sort_impl<span class="op">(</span>RandomIt begin<span class="op">,</span> RandomIt end<span class="op">);</span></span></code></pre></div>
<p>Didn’t we say that declaring templates didn’t work? Not quite. We can
still declare them, but we need to have their definition in the same
translation unit. We just want to write the definitions below the
definition of sort.</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Why not make sort work on any container that has begin, end, and random</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="co">// access iterators?</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Container<span class="op">&gt;</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>Container sort<span class="op">(</span>Container v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    sort_impl<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v<span class="op">;</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> RandomIt<span class="op">&gt;</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sort_impl<span class="op">(</span>RandomIt begin<span class="op">,</span> RandomIt end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>end <span class="op">-</span> begin <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Notice how usage of auto means we can leave more code unchanged.</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pivot <span class="op">=</span> partition<span class="op">(</span>begin<span class="op">,</span> end<span class="op">);</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    sort_impl<span class="op">(</span>begin<span class="op">,</span> pivot<span class="op">);</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>    sort_impl<span class="op">(</span>pivot<span class="op">+</span><span class="dv">1</span><span class="op">,</span> end<span class="op">);</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> RandomIt<span class="op">&gt;</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>RandomIt partition<span class="op">(</span>RandomIt begin<span class="op">,</span> RandomIt end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pivot <span class="op">=</span> begin<span class="op">++;</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(;</span> begin <span class="op">!=</span> end<span class="op">;</span> <span class="op">++</span>begin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*</span>pivot <span class="op">&gt;</span> <span class="op">*</span>begin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>swap<span class="op">(*</span>pivot<span class="op">,</span> <span class="op">*</span>begin<span class="op">);</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span>pivot<span class="op">;</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>swap<span class="op">(*</span>pivot<span class="op">,</span> <span class="op">*</span>begin<span class="op">);</span></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pivot<span class="op">;</span></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a><span class="co">// I&#39;ll leave converting our binary search function into a function template as</span></span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a><span class="co">// an exercise to the reader.</span></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator binary_search<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">,</span> <span class="dt">int</span> val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> bottom <span class="op">=</span> v<span class="op">.</span>begin<span class="op">(),</span> top <span class="op">=</span> v<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>top <span class="op">!=</span> bottom<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> mid <span class="op">=</span> bottom <span class="op">+</span> <span class="op">(</span>top <span class="op">-</span> bottom<span class="op">)/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*</span>mid <span class="op">&lt;</span> val<span class="op">)</span></span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a>            bottom <span class="op">=</span> mid<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(*</span>mid <span class="op">&gt;</span> val<span class="op">)</span></span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a>            top <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb47-48"><a href="#cb47-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mid<span class="op">;</span></span>
<span id="cb47-49"><a href="#cb47-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-50"><a href="#cb47-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-51"><a href="#cb47-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb47-52"><a href="#cb47-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now that you’ve seen how templates are implemented, let’s take a look
at our main function.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-13---exceptions">Chapter 13 - Exceptions</h1>
<h2 id="io.hpp">io.hpp</h2>
<div class="sourceCode" id="cb49"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_13_IO_HPP</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_13_IO_HPP</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span></code></pre></div>
<p>We’re going to define a function template that reads a value of the
type we specify. If it can’t read the value, it’ll throw an instance of
std::runtime_error.</p>
<p>C++ allows us to throw values of most types, but there are types that
are specifically designed to be thrown, and we should generally limit
ourselves to those. We will later see how to create our own, which means
this will not be a severe limitation.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>T read<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream <span class="op">=</span> <span class="bu">std::</span>cin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    T result<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If everything went fine, we return.</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream <span class="op">&gt;&gt;</span> result<span class="op">)</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If we hit the end of file, report that</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">.</span>eof<span class="op">())</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;read failed; EOF encountered.&quot;</span><span class="op">};</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// otherwise, the input wasn&#39;t in the format we expected.</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;read failed; malformed input.&quot;</span><span class="op">};</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When we call read to take some input, we can’t accidentally ignore an
error. We can write a catcher that does nothing to explicitly silence
it, but if we simply forget to write a catcher, the exception will fly
right through our code and out of main. If that happens, our program
will terminate.</p>
<p>Let’s take a look at math.hpp now, where we’ll also use
exceptions.</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="main.cpp-13">main.cpp</h2>
<p>Recommended read order: main.cpp (beginning), io.hpp, math.hpp,
math.cpp, main.cpp (end)</p>
<p>In this chapter, we’re going to look at an approach to dealing with
errors: namely, exception handling.</p>
<p>Let’s first recap the way we’ve already seen though: error flags.
We’ve seen that when we use an istream and a read fails, it is set to a
fail state, which we can then check for. We can query it for whether the
failure was caused by invalid input or by there not being any more input
to read, and then clear the errors once we’re ready to continue.</p>
<p>Notice that nobody forces us to check the error flags. In chapter 2,
we skipped that step, because we didn’t know about if statements yet. We
have been doing it systematically since then, but only for std::cin:
we’ve never checked whether our output to std::cout would work, just
assuming that everything would be fine. If anything ever did go wrong,
our program would never notice.</p>
<p>Exceptions take a different approach to the problem. They split the
work between two pieces of code: the thrower and the catcher.</p>
<p>The thrower is the code that reports an error. It looks almost like a
return statement:</p>
<p><code>throw expression;</code></p>
<p>The expression is evaluated, and its value becomes the exception.
Just like when you return a value the function doesn’t continue as
normal, throwing a value breaks the normal flow of control. Instead of
continuing with the next statement, the program looks for a catcher. If
none is found in the current function, the function that called this one
is looked at; and so on, until we’ve found a catcher or checked main and
found that nobody is willing to handle our error.</p>
<p>The catcher is the code that claims to be able to deal with the
error. It looks like this:</p>
<p><code>try {</code></p>
<p><code>throwing statements...</code></p>
<p><code>}</code></p>
<p><code>catch (type x) {</code></p>
<p><code>handling statements...</code></p>
<p><code>}</code></p>
<p><code>catch (other_type x) {</code></p>
<p><code>other handling statements...</code></p>
<p><code>}</code></p>
<p>The catcher specifies some potentially throwing statements by putting
them in a try clause. It then lists at least one catch clause: the word
catch, followed by what looks like a parameter list, but it’s limited to
one parameter. The type of that parameter is used to know what
exceptions we want to catch.</p>
<p>When an exception is thrown, its type is remembered. A catcher is
found, and then its catch clauses are inspected from top to bottom. If
any of them have a suitable type, that catch clause is run and the
statements in there should handle the error. If we’ve checked all
catchers up to main and nobody is willing to handle this type of
exception, the program terminates.</p>
<p>We can see this system as one of passing around responsibility. When
you call a function, you make it responsible for computing a certain
value. If a function cannot do that, it can throw an exception. It loses
its responsibility (and thus also its right to keep executing), and we
look at each caller in turn to see who is willing to accept this
responsibility. Whoever does has his handler code run. If nobody does,
no code is run, and your program grinds to a halt.</p>
<p>Go ahead and look at io.hpp for an example involving streams.</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;io.hpp&quot;</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;math.hpp&quot;</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co">// When an entire function is a catcher, we can use a so-called function try</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="co">// block.  In this case, it&#39;s a matter of personal preference whether you do it</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="co">// this way or just by having a normal try block.  We&#39;ll see some cases where</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="co">// you can&#39;t avoid using it later.</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter a: &quot;</span><span class="op">;</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> read<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;();</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter b: &quot;</span><span class="op">;</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> read<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;();</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter c: &quot;</span><span class="op">;</span></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> c <span class="op">=</span> read<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;();</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> result <span class="op">=</span> find_roots<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> c<span class="op">);</span></span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;First root: &quot;</span> <span class="op">&lt;&lt;</span> result<span class="op">.</span>first <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Second root: &quot;</span> <span class="op">&lt;&lt;</span> result<span class="op">.</span>second <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Notice how we don&#39;t have to do any error-checking here.  It&#39;s all done by</span></span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// read and find_roots; if anything goes wrong, an exception will be thrown</span></span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and we&#39;ll catch it below.  We&#39;ve separated the code that does the work</span></span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// from the code that handles the errors.</span></span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a><span class="co">// Now that we&#39;re at our error-handling part, what do we catch?  The two error</span></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a><span class="co">// types we threw were std::runtime_error and std::domain_error.  We could write</span></span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a><span class="co">// individual catch blocks for each, but there&#39;s a better solution.</span></span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a><span class="co">// C++ types don&#39;t have to be entirely distinct.  A type A can be a subtype of a</span></span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a><span class="co">// type B; that means that every value of type A also has type B.  We say B is a</span></span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a><span class="co">// supertype of A.  In this case, std::runtime_error and std::domain_error both</span></span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a><span class="co">// share a supertype std::exception, so catching std::exception will catch both</span></span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a><span class="co">// of them.</span></span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a><span class="co">// However, a subtype may say more about the value than the supertype does.  If</span></span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a><span class="co">// we catch std::exception by value, we will be copying the std::runtime_error</span></span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a><span class="co">// and std::domain_error, which may lose us data.  Instead, we&#39;ll catch it by</span></span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a><span class="co">// reference: seeing as our value has type std::exception that is allowed, and</span></span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a><span class="co">// seeing as our reference refers to the original object, no data loss can</span></span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a><span class="co">// occur.</span></span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// e.what() returns the message we attached to the std::runtime_error or</span></span>
<span id="cb52-43"><a href="#cb52-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::domain_error</span></span>
<span id="cb52-44"><a href="#cb52-44" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Error: &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb52-45"><a href="#cb52-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb52-46"><a href="#cb52-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-47"><a href="#cb52-47" aria-hidden="true" tabindex="-1"></a><span class="co">// As I said before, we really don&#39;t want exceptions escaping main.  We can use</span></span>
<span id="cb52-48"><a href="#cb52-48" aria-hidden="true" tabindex="-1"></a><span class="co">// a catch (...) clause to catch errors of any type.  However, as the value can</span></span>
<span id="cb52-49"><a href="#cb52-49" aria-hidden="true" tabindex="-1"></a><span class="co">// be of any type, it doesn&#39;t make sense for us to be able to inspect it; we</span></span>
<span id="cb52-50"><a href="#cb52-50" aria-hidden="true" tabindex="-1"></a><span class="co">// wouldn&#39;t know what to do with it!</span></span>
<span id="cb52-51"><a href="#cb52-51" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb52-52"><a href="#cb52-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Unknown error.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb52-53"><a href="#cb52-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb52-54"><a href="#cb52-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So far, I’ve been talking about exceptions as an altogether positive
solution. This is not an opinion held by everyone – you’ll find that
quite a few people aren’t particularly fond of exceptions.</p>
<p>Put simply: exceptions are the Hard Mode of C++. If you’re coding
with exceptions, a large number of your expressions can throw, meaning
that only part of your code will be executed, while the rest will be
skipped. You have to make sure that this isn’t a problem. Again: you
have to make sure, for every piece of code, that either it does not (and
never will!) throw an exception, or that only part of the code being
executed does not corrupt your program state in any way. You can use
catch clauses to fix some things, but we will need more powerful tools
to handle all the problems that this brings us.</p>
<p>Some examples:</p>
<p><code>foo();</code></p>
<p><code>bar();</code></p>
<p>Up to now, we knew foo would be called, then bar would be called. In
hard mode, there’s a chance foo will throw an exception and bar won’t be
called.</p>
<p><code>bar(foo());</code></p>
<p>Same as above. We cannot assume bar will be called, unless we proved
some very strong claims about foo.</p>
<p><code>bar(foo(), faa())</code></p>
<p>Earlier, we knew foo and faa would be called in some unspecified
order. After that, bar would be called with the results. In hard mode,
all of these are possible:</p>
<ul>
<li>foo called but throws, others never called</li>
<li>faa called but throws, others never called</li>
<li>foo called successfully, faa called but throws, bar never
called</li>
<li>faa called successfully, foo called but throws, bar never
called</li>
<li>foo called successfully, faa called successfully, bar called but
throws</li>
<li>faa called successfully, foo called successfully, bar called but
throws</li>
</ul>
<p>Let’s add another one:</p>
<p><code>bar(foo(), faa(), fee())</code></p>
<p>We couldn’t be sure about what order these would be called in, but
we’d knew all three of foo, faa, and fee would be called, and then bar
would be. Now the situation is as above, but with even more options.
Perhaps faa will be called and complete successfully, and then foo will
throw, so that fee is never called. Perhaps things will happen in some
other order. In general, you cannot know, and you’ll have a lot of code
on your hands if you write a catch clause for every function you
call.</p>
<p>If exceptions make C++ harder, why use them? It turns out that making
our code exception-safe is often a good idea anyway. When you have a
group of functions that must always be executed together, it generally
pays to put a little extra effort into guaranteeing that; even if
exceptions don’t break it, a careless code change or a change in design
might.</p>
<p>Besides, it isn’t all doom and gloom. Solutions to many of these
problems have been found, and once generalised, they can save effort. In
the end, once the pitfalls have been studied and bridges have been
built, the results are better.</p>
<p>In my opinion, anyway.</p>
<h2 id="math.cpp">math.cpp</h2>
<div class="sourceCode" id="cb53"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;math.hpp&quot;</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a straightforward implementation of the quadratic formula:</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="co">// http://en.wikipedia.org/wiki/Quadratic_formula</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> find_roots<span class="op">(</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span> <span class="dt">double</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Nobody forces us to use const when dealing with locals, but it is a</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sensible thing to do if you know the value will not change.</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> determinant <span class="op">=</span> b<span class="op">*</span>b <span class="op">-</span> <span class="dv">4</span><span class="op">*</span>a<span class="op">*</span>c<span class="op">;</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Instead of throwing std::runtime_error, we throw std::domain_error.  This</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// is a very similar type, varying mostly in name.  It is intended to be</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// used when &quot;a mathematical function is not defined for the value of the</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// argument&quot;, which is what we have here.</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>determinant <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>domain_error<span class="op">{</span><span class="st">&quot;no real roots.&quot;</span><span class="op">};</span></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::sqrt returns the square root of its argument.</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We make these to save ourselves from computing some values twice.</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> two_a <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>a<span class="op">;</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> d_part <span class="op">=</span> <span class="bu">std::</span>sqrt<span class="op">(</span>determinant<span class="op">);</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::make_pair makes a pair.  Duh.</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>make_pair<span class="op">((-</span>b<span class="op">+</span>d_part<span class="op">)/</span>two_a<span class="op">,</span> <span class="op">(-</span>b<span class="op">-</span>d_part<span class="op">)/</span>two_a<span class="op">);</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We’ve now written all our throwers. They throw std::runtime_error and
std::domain_error, so we’ll want to catch those two in main. Let’s go
there and make that work.</p>
<h2 id="math.hpp">math.hpp</h2>
<div class="sourceCode" id="cb54"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_13_MATH_HPP</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_13_MATH_HPP</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="co">// The equation will likely have two roots, so we return an std::pair.  This is</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="co">// just a type that lets us store two values; if we have a pair p then the first</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="co">// value can be accessed as p.first, and the second as p.second.  Nothing</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="co">// spectacular, but it means we can return two values.</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> find_roots<span class="op">(</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span> <span class="dt">double</span> c<span class="op">);</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-14---project-overview">Chapter 14 - Project
Overview</h1>
<h2 id="main.cpp-14">main.cpp</h2>
<p>Over the next few chapters, we’ll be writing a simple lexer, parser,
and interpreter for a LISP-like language.</p>
<p>Many of the features of C++ are intended for larger programs. While
they could all be demonstrated in smaller examples, I expect this to do
nothing but obscure the purpose of the thing.</p>
<p>Let’s take a high-level overview of the project: - First we’ll want
to write some code that we can use to split the input into logical
chunks, skipping anything we’re not interested in (like whitespace). We
don’t need anything new for that, so this chapter will cover it fully. -
We’ll then want to be able to store these chunks, which we’ll call
tokens. A number of chapters will be spent on improving the
representation. - Working directly with the sequence of tokens would be
inconvenient, so we write a helper to automate the common tasks. - Once
we can work with the tokens easily, we’ll write a function that can
analyze the structure in order to make a tree. We’ll see the details
later. - We’ll spend some time looking at how we can represent
homogenous and heterogenous trees, and how we can perform computations
over them. - Some implementation details like symbol tables may need
more attention. - Finally, we’ll put everything together to make both an
interpreter for files and a REPL.</p>
<p>If you’ve never seen Lisp before, it looks roughly like this:</p>
<p>(+ (* 2 2) 3)</p>
<p>In C++, this expression would look like</p>
<p>(2*2) + 3</p>
<p>We can also define variables:</p>
<p>(define x 5)</p>
<p>and have so-called lambda-functions</p>
<p>(lambda (x) (* x x))</p>
<p>the above is a function that takes a single parameter x and returns
x*x.</p>
<p>We’ll also support the -, /, ==, !=, &lt;, &lt;=, &gt;, &gt;=
operators and an if function. This means the factorial function can be
written as:</p>
<p>(define factorial</p>
<p><code>(lambda (x)</code></p>
<p><code>(if (&lt;= x 1)</code></p>
<p><code>0</code></p>
<p><code>(* x (factorial (- x 1))))))</code></p>
<p>Translated to C++, the above is almost exactly the same as</p>
<p>int factorial(int x) {</p>
<p><code>if (x &lt;= 1)</code></p>
<p><code>return 0;</code></p>
<p><code>else</code></p>
<p><code>return x * factorial(x-1);</code></p>
<p>}</p>
<p>Leaving aside the question of which one looks better, we can guess
that the Lisp version is going to be much easier to write a program to
evaluate.</p>
<p>We have five kinds of tokens: - opening parentheses - closing
parentheses - operators (sequences of +*-/!=&lt;&gt;) - names (sequences
of letters) - numbers (sequences of digits)</p>
<p>However, notice that we can use operators and names interchangably.
This means that we don’t have to make a separate category for them. We
end up with four categories: open_paren, close_paren, name and
number.</p>
<p>It also helps to have a special token type for the end of the file.
This serves a double purpose: it means we know when to stop asking for
more tokens, and it lets us check that all input has indeed been
handled. Seeing as we’re just printing the tokens for now it may not
seem like that big a difference, but by the next chapter we’ll be glad
we did it.</p>
<p>Apart from knowing that a name or number was seen, we’d also like to
know what name or number it was. This means that every token should have
an associated string. For opening and closing parentheses this could be
omitted, as they are always the same, but doing so at this point would
be more trouble than it’s worth.</p>
<p>All in all, we want a program that can take</p>
<p>(+ foo 24)</p>
<p>And print</p>
<p>{ open_paren: “(” } { name: “+” } { name: “foo” } { number: “24” } {
close_paren: “)” } { end_of_file: “” }</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="co">// As usual, we&#39;ll split our program into a few functions.</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Does exactly what it says on the tin and is our main &quot;driving&quot; function.</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="co">// All the other parsing functions are called from here.</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_next_token<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Let&#39;s get the implementation of main out of the way before we look at more</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a><span class="co">// specific things.</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>cin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>        print_next_token<span class="op">(</span><span class="bu">std::</span>cin<span class="op">);</span></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Error: &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Unknown error.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb55-27"><a href="#cb55-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-28"><a href="#cb55-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-29"><a href="#cb55-29" aria-hidden="true" tabindex="-1"></a><span class="co">// Well, that was quick and painless.  Now on to the less painless parts:</span></span>
<span id="cb55-30"><a href="#cb55-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-31"><a href="#cb55-31" aria-hidden="true" tabindex="-1"></a><span class="co">// We&#39;ll use helper functions for lexing the non-trivial symbols.  The simpler</span></span>
<span id="cb55-32"><a href="#cb55-32" aria-hidden="true" tabindex="-1"></a><span class="co">// ones can go right in print_next_token.</span></span>
<span id="cb55-33"><a href="#cb55-33" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> lex_name<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb55-34"><a href="#cb55-34" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> lex_number<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb55-35"><a href="#cb55-35" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> lex_operator<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb55-36"><a href="#cb55-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-37"><a href="#cb55-37" aria-hidden="true" tabindex="-1"></a><span class="co">// Let&#39;s write a function to check for tokens that are allowed in operators.</span></span>
<span id="cb55-38"><a href="#cb55-38" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isoperator<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-39"><a href="#cb55-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::string&#39;s find returns the position of the character, or</span></span>
<span id="cb55-40"><a href="#cb55-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::string::npos if the character isn&#39;t found.</span></span>
<span id="cb55-41"><a href="#cb55-41" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span> valid_chars <span class="op">=</span> <span class="st">&quot;+*-/!=&lt;&gt;&quot;</span><span class="op">;</span></span>
<span id="cb55-42"><a href="#cb55-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> valid_chars<span class="op">.</span>find<span class="op">(</span>c<span class="op">)</span> <span class="op">!=</span> <span class="bu">std::</span>string::npos<span class="op">;</span></span>
<span id="cb55-43"><a href="#cb55-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-44"><a href="#cb55-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-45"><a href="#cb55-45" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_next_token<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-46"><a href="#cb55-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We want to parse the input character-by-character.  We&#39;ll store the</span></span>
<span id="cb55-47"><a href="#cb55-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// character we&#39;re currently parsing in c</span></span>
<span id="cb55-48"><a href="#cb55-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb55-49"><a href="#cb55-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Here&#39;s a loop somewhat unlike what we&#39;ve seen before -- instead of a body</span></span>
<span id="cb55-50"><a href="#cb55-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it&#39;s just got a semicolon after it.  That&#39;s allowed: the semicolon is an</span></span>
<span id="cb55-51"><a href="#cb55-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// empty statement, which is a valid body.  You can read this as &quot;while the</span></span>
<span id="cb55-52"><a href="#cb55-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// condition is true, do nothing&quot;.</span></span>
<span id="cb55-53"><a href="#cb55-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb55-54"><a href="#cb55-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Why is this useful?  Our condition is what&#39;s doing the work.  The &amp;&amp;</span></span>
<span id="cb55-55"><a href="#cb55-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">// operator is defined to first evaluate what&#39;s on the left of it, and only</span></span>
<span id="cb55-56"><a href="#cb55-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">// if that is true will the right-hand side ever be evaluated.</span></span>
<span id="cb55-57"><a href="#cb55-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// stream.get(c) is true if and only if it managed to extract a character</span></span>
<span id="cb55-58"><a href="#cb55-58" aria-hidden="true" tabindex="-1"></a>    <span class="co">// into c.  After that, we use std::isspace to check whether that character</span></span>
<span id="cb55-59"><a href="#cb55-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">// is a space.  This means that characters will keep getting extracted as</span></span>
<span id="cb55-60"><a href="#cb55-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">// long as they&#39;re whitespace, and once the loop is done, either we&#39;ve read</span></span>
<span id="cb55-61"><a href="#cb55-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">// all the input we had or c is a non-whitespace character.</span></span>
<span id="cb55-62"><a href="#cb55-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isspace<span class="op">(</span>c<span class="op">));</span></span>
<span id="cb55-63"><a href="#cb55-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-64"><a href="#cb55-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now that we&#39;ve ignored the spaces, we can check whether there&#39;s anything</span></span>
<span id="cb55-65"><a href="#cb55-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">// more to parse:</span></span>
<span id="cb55-66"><a href="#cb55-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-67"><a href="#cb55-67" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;{ end_of_file: </span><span class="sc">\&quot;\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb55-68"><a href="#cb55-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb55-69"><a href="#cb55-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-70"><a href="#cb55-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-71"><a href="#cb55-71" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can check if the character is a parenthesis...</span></span>
<span id="cb55-72"><a href="#cb55-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;(&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-73"><a href="#cb55-73" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;{ open_paren: </span><span class="sc">\&quot;</span><span class="st">(</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb55-74"><a href="#cb55-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb55-75"><a href="#cb55-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-76"><a href="#cb55-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-77"><a href="#cb55-77" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;{ close_paren: </span><span class="sc">\&quot;</span><span class="st">)</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb55-78"><a href="#cb55-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb55-79"><a href="#cb55-79" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-80"><a href="#cb55-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-81"><a href="#cb55-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If it isn&#39;t any of the above, it must be a name or number.  We&#39;ve</span></span>
<span id="cb55-82"><a href="#cb55-82" aria-hidden="true" tabindex="-1"></a>    <span class="co">// declared functions for parsing those three things already, so we just</span></span>
<span id="cb55-83"><a href="#cb55-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">// need to select the right function.  However, those functions don&#39;t take a</span></span>
<span id="cb55-84"><a href="#cb55-84" aria-hidden="true" tabindex="-1"></a>    <span class="co">// char for the first symbol, which we&#39;ve already extracted, so if we just</span></span>
<span id="cb55-85"><a href="#cb55-85" aria-hidden="true" tabindex="-1"></a>    <span class="co">// called one of them with the rest of the stream, we would end up skipping</span></span>
<span id="cb55-86"><a href="#cb55-86" aria-hidden="true" tabindex="-1"></a>    <span class="co">// over the first character of whatever we were parsing.</span></span>
<span id="cb55-87"><a href="#cb55-87" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb55-88"><a href="#cb55-88" aria-hidden="true" tabindex="-1"></a>    <span class="co">// To fix this we &quot;unget&quot; the character we extracted.  We can still use c,</span></span>
<span id="cb55-89"><a href="#cb55-89" aria-hidden="true" tabindex="-1"></a>    <span class="co">// as its value won&#39;t be changed by this, but now our lexing functions will</span></span>
<span id="cb55-90"><a href="#cb55-90" aria-hidden="true" tabindex="-1"></a>    <span class="co">// see the whole token.</span></span>
<span id="cb55-91"><a href="#cb55-91" aria-hidden="true" tabindex="-1"></a>    stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb55-92"><a href="#cb55-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-93"><a href="#cb55-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb55-94"><a href="#cb55-94" aria-hidden="true" tabindex="-1"></a>        lex_name<span class="op">(</span>stream<span class="op">);</span></span>
<span id="cb55-95"><a href="#cb55-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb55-96"><a href="#cb55-96" aria-hidden="true" tabindex="-1"></a>        lex_number<span class="op">(</span>stream<span class="op">);</span></span>
<span id="cb55-97"><a href="#cb55-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb55-98"><a href="#cb55-98" aria-hidden="true" tabindex="-1"></a>        lex_operator<span class="op">(</span>stream<span class="op">);</span></span>
<span id="cb55-99"><a href="#cb55-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="co">// we couldn&#39;t recognise the character</span></span>
<span id="cb55-100"><a href="#cb55-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;unrecognised character&quot;</span><span class="op">};</span></span>
<span id="cb55-101"><a href="#cb55-101" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-102"><a href="#cb55-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-103"><a href="#cb55-103" aria-hidden="true" tabindex="-1"></a><span class="co">// Now let&#39;s write our lexing functions</span></span>
<span id="cb55-104"><a href="#cb55-104" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> lex_name<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-105"><a href="#cb55-105" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb55-106"><a href="#cb55-106" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb55-107"><a href="#cb55-107" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is similar to the whitespace-clearing loop above, but now we store</span></span>
<span id="cb55-108"><a href="#cb55-108" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the character in a string.  Pushing-backing into a string works just like</span></span>
<span id="cb55-109"><a href="#cb55-109" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it does with a vector.</span></span>
<span id="cb55-110"><a href="#cb55-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb55-111"><a href="#cb55-111" aria-hidden="true" tabindex="-1"></a>        name<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb55-112"><a href="#cb55-112" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We don&#39;t want the last character we extracted to disappear.</span></span>
<span id="cb55-113"><a href="#cb55-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">)</span></span>
<span id="cb55-114"><a href="#cb55-114" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb55-115"><a href="#cb55-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-116"><a href="#cb55-116" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;{ name: </span><span class="sc">\&quot;</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> name <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb55-117"><a href="#cb55-117" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-118"><a href="#cb55-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-119"><a href="#cb55-119" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> lex_number<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-120"><a href="#cb55-120" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb55-121"><a href="#cb55-121" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string number<span class="op">;</span></span>
<span id="cb55-122"><a href="#cb55-122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb55-123"><a href="#cb55-123" aria-hidden="true" tabindex="-1"></a>        number<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb55-124"><a href="#cb55-124" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">)</span></span>
<span id="cb55-125"><a href="#cb55-125" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb55-126"><a href="#cb55-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-127"><a href="#cb55-127" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;{ number: </span><span class="sc">\&quot;</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> number <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb55-128"><a href="#cb55-128" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-129"><a href="#cb55-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-130"><a href="#cb55-130" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> lex_operator<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-131"><a href="#cb55-131" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb55-132"><a href="#cb55-132" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string op<span class="op">;</span></span>
<span id="cb55-133"><a href="#cb55-133" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb55-134"><a href="#cb55-134" aria-hidden="true" tabindex="-1"></a>        op<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb55-135"><a href="#cb55-135" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">)</span></span>
<span id="cb55-136"><a href="#cb55-136" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb55-137"><a href="#cb55-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-138"><a href="#cb55-138" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;{ name: </span><span class="sc">\&quot;</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> op <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb55-139"><a href="#cb55-139" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-140"><a href="#cb55-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-141"><a href="#cb55-141" aria-hidden="true" tabindex="-1"></a><span class="co">// Tada!  Notice how similar lex_name, lex_number and lex_operator are.</span></span>
<span id="cb55-142"><a href="#cb55-142" aria-hidden="true" tabindex="-1"></a><span class="co">// Eventually we&#39;ll be able to make these things less similar.</span></span></code></pre></div>
<p>We can now recognise different tokens. Next we’ll look at how we can
represent these tokens inside the program so that we can pass them to
and from functions and make vectors of them. You can probably guess that
std::pair&lt;std::string, std::string&gt; would do the job, but C++
offers a neater solution.</p>
<h1 id="chapter-15---basic-structs">Chapter 15 - Basic Structs</h1>
<h2 id="lex.cpp">lex.cpp</h2>
<div class="sourceCode" id="cb56"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lex.hpp&quot;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="co">// We want these to return a token.</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>Token lex_name<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>Token lex_number<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>Token lex_operator<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isoperator<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span> valid_chars <span class="op">=</span> <span class="st">&quot;+*-/!=&lt;&gt;&quot;</span><span class="op">;</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> valid_chars<span class="op">.</span>find<span class="op">(</span>c<span class="op">)</span> <span class="op">!=</span> <span class="bu">std::</span>string::npos<span class="op">;</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Most of this function is unchaged.</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>Token extract_next_token<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isspace<span class="op">(</span>c<span class="op">));</span></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Here&#39;s the first difference.  We don&#39;t print anything; instead, we</span></span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// create a Token and return it.  We could use the Token{...} syntax</span></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// described earlier, but the compiler already knows we want a Token, so</span></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we can just use {...}.  In particular, as type and value were defined</span></span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// in that order, when we say Token{x, y}, type will be initialised with</span></span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// x and value will be initialised with y.</span></span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>end_of_file_token<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">};</span></span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;(&#39;</span><span class="op">)</span></span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>open_paren_token<span class="op">,</span> <span class="st">&quot;(&quot;</span><span class="op">};</span></span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span></span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>close_paren_token<span class="op">,</span> <span class="st">&quot;)&quot;</span><span class="op">};</span></span>
<span id="cb56-34"><a href="#cb56-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-35"><a href="#cb56-35" aria-hidden="true" tabindex="-1"></a>    stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb56-36"><a href="#cb56-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-37"><a href="#cb56-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb56-38"><a href="#cb56-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_name<span class="op">(</span>stream<span class="op">);</span></span>
<span id="cb56-39"><a href="#cb56-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb56-40"><a href="#cb56-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_number<span class="op">(</span>stream<span class="op">);</span></span>
<span id="cb56-41"><a href="#cb56-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb56-42"><a href="#cb56-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_operator<span class="op">(</span>stream<span class="op">);</span></span>
<span id="cb56-43"><a href="#cb56-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-44"><a href="#cb56-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If we haven&#39;t returned by now, something is wrong.</span></span>
<span id="cb56-45"><a href="#cb56-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;unrecognised character&quot;</span><span class="op">};</span></span>
<span id="cb56-46"><a href="#cb56-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb56-47"><a href="#cb56-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-48"><a href="#cb56-48" aria-hidden="true" tabindex="-1"></a>Token lex_name<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-49"><a href="#cb56-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb56-50"><a href="#cb56-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb56-51"><a href="#cb56-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb56-52"><a href="#cb56-52" aria-hidden="true" tabindex="-1"></a>        name<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb56-53"><a href="#cb56-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-54"><a href="#cb56-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">)</span></span>
<span id="cb56-55"><a href="#cb56-55" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb56-56"><a href="#cb56-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-57"><a href="#cb56-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> name<span class="op">};</span></span>
<span id="cb56-58"><a href="#cb56-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb56-59"><a href="#cb56-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-60"><a href="#cb56-60" aria-hidden="true" tabindex="-1"></a>Token lex_number<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-61"><a href="#cb56-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb56-62"><a href="#cb56-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string number<span class="op">;</span></span>
<span id="cb56-63"><a href="#cb56-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb56-64"><a href="#cb56-64" aria-hidden="true" tabindex="-1"></a>        number<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb56-65"><a href="#cb56-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-66"><a href="#cb56-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">)</span></span>
<span id="cb56-67"><a href="#cb56-67" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb56-68"><a href="#cb56-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-69"><a href="#cb56-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>number_token<span class="op">,</span> number<span class="op">};</span></span>
<span id="cb56-70"><a href="#cb56-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb56-71"><a href="#cb56-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-72"><a href="#cb56-72" aria-hidden="true" tabindex="-1"></a>Token lex_operator<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-73"><a href="#cb56-73" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb56-74"><a href="#cb56-74" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string op<span class="op">;</span></span>
<span id="cb56-75"><a href="#cb56-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb56-76"><a href="#cb56-76" aria-hidden="true" tabindex="-1"></a>        op<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb56-77"><a href="#cb56-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-78"><a href="#cb56-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">)</span></span>
<span id="cb56-79"><a href="#cb56-79" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb56-80"><a href="#cb56-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-81"><a href="#cb56-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> op<span class="op">};</span></span>
<span id="cb56-82"><a href="#cb56-82" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now that we can do this, let’s go back to main and show that we can
make a vector of Tokens using all this.</p>
<h2 id="lex.hpp">lex.hpp</h2>
<div class="sourceCode" id="cb57"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_15_LEX_HPP</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_15_LEX_HPP</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span></code></pre></div>
<p>Now that we’ve defined the Token type, we can use it like just about
any other kind of type. It doesn’t have all that many operations defined
on it yet – we can copy and assign it, but not compare it, for instance
– but we have enough to create them and return them from functions.</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Instead of print_next_token we have an extract_next_token which reads a token</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co">// and returns it.</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="co">// All other lexing functions are implementation details, so we don&#39;t declare</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="co">// them in the header.</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>Token extract_next_token<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="main.cpp-15">main.cpp</h2>
<p>Suggested reading order: main.cpp (beginning), token.hpp, lex.hpp,
lex.cpp, main.cpp (rest)</p>
<p>We’ve seen how we can print the tokens present in a stream. Now,
instead of simply outputting the tokens we’d like to return them.</p>
<p>First of all, we’d like to have a name for each kind of token:
name_token, open_paren_token, close_paren_token, number_token, and
end_of_file_token. We don’t really care what the type of these is, as
long as we can assign them and compare them for equality.</p>
<p>Once we have that, we’d like Token to be a type. If tok is an
instance of token, we want tok.type to be the type of token tok is, and
tok.value to be the string associated with tok.</p>
<p>Proceed to token.hpp and we’ll take a look at how we can create such
a type.</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lex.hpp&quot;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_token<span class="op">(</span>Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;{ &quot;</span><span class="op">;</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This chain of ifs and elses doesn&#39;t look particularly good.  We&#39;ll see</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// how we can make it better later on.</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> open_paren_token<span class="op">)</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;open_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> close_paren_token<span class="op">)</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;close_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> name_token<span class="op">)</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;name_token&quot;</span><span class="op">;</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> number_token<span class="op">)</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;number_token&quot;</span><span class="op">;</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> end_of_file_token<span class="op">)</span></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;end_of_file_token&quot;</span><span class="op">;</span></span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;, </span><span class="sc">\&quot;</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> tok<span class="op">.</span>value <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st"> }</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>Token<span class="op">&gt;</span> tokens<span class="op">;</span></span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>cin<span class="op">)</span></span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a>        tokens<span class="op">.</span>push_back<span class="op">(</span>extract_next_token<span class="op">(</span><span class="bu">std::</span>cin<span class="op">));</span></span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>for_each<span class="op">(</span>tokens<span class="op">.</span>begin<span class="op">(),</span> tokens<span class="op">.</span>end<span class="op">(),</span> print_token<span class="op">);</span></span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-33"><a href="#cb59-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Error: &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb59-34"><a href="#cb59-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb59-35"><a href="#cb59-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb59-36"><a href="#cb59-36" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb59-37"><a href="#cb59-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Unknown error.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb59-38"><a href="#cb59-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb59-39"><a href="#cb59-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can now operate on tokens from inside the program. It is tempting
to immediately continue to parsing and tree-construction, but there’s no
need to rush. There are a number of places where the current
implementation is suboptimal and we should take a look at those before
we move on to more advanced matters.</p>
<p>In particular, we can make it possible to compare tokens using == and
!= and input and output them using &gt;&gt; and &lt;&lt;. We can also
make print_token neater and finally get a proper introduction to the
name::other_name syntax that we’ve been using without a proper
explanation for far too long.</p>
<h2 id="token.hpp">token.hpp</h2>
<div class="sourceCode" id="cb60"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_15_TOKEN_HPP</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_15_TOKEN_HPP</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span></code></pre></div>
<p>Let’s start by defining the token types. We’ll make them int consts;
we will see a better solution soon, but this will do until we’ve had a
chance to introduce that.</p>
<p>There’s two reasons to make them const here: the first and most
important one is that it makes no sense for anyone to modify them: after
all, they’re just tags and their values, as long as they’re all
different, don’t really matter.</p>
<p>The other reason is that marking them const means we can define them
in the header. Had they been normal ints this would lead to double
definition errors, but because the type is const they are excluded from
that rule and may be defined multiple times in different translation
units, as long as the definitions are all the same.</p>
<p>By the way, yes, you are allowed to define arbitrary variables
outside functions. However, doing so is a sure way to make your project
a tangled mess. Chances are that if you wanted to do this, the features
of structs we’ll be looking at shortly will provide a better
solution.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> open_paren_token <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> close_paren_token <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> name_token <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> number_token <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> end_of_file_token <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span></code></pre></div>
<p>With that out of the way, we can look at creating the Token type. The
syntax for that is, very roughly:</p>
<p>struct name {</p>
<p><code>members...</code></p>
<p>} instances…;</p>
<p>For now, members are just variable declarations; they’ll become much
more as we progress, but there’s no need to worry about that for now.
instances are an interesting historical curiousity. They allow us to
immediately define variables of the type we just defined. You won’t see
them used all that often, but knowing that they’re allowed explains why
you need a semicolon at the end of your struct definition.</p>
<p>Now, our Token type:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co">// We wanted the name to be Token, and we wanted tok.type and tok.value to be</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="co">// available.</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Note that we use int for type, even though open_paren_token and friends are</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="co">// all int const.  Note that when we say tok_a = tok_b, we overwrite tok_a&#39;s</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="co">// type and value members.  If we were to use int const here, that overwrite</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="co">// would be illegal and we wouldn&#39;t be able to assign Tokens to each other.</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> type<span class="op">;</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string value<span class="op">;</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Note that I did say struct <em>definition</em>. struct declarations
exist, too: if we wanted to only declare Token and not define it, we
could have said</p>
<p>struct Token;</p>
<p>However, Token would be a so-called incomplete type, meaning we
couldn’t make instances of it or use any members; after all, we don’t
know which ones it has.</p>
<p>Why are we allowed to put a struct definition in a header? This is
yet another case of multiple definitions being allowed in different
translation units if they are identical. The definition of Token is
something that most code that uses Token needs, so it would be very
impractical if we could only define it in one translation unit.</p>
<p>Continue to lex.hpp.</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-16---basic-operator-overloading">Chapter 16 - Basic
Operator Overloading</h1>
<h2 id="lex.cpp-1">lex.cpp</h2>
<div class="sourceCode" id="cb64"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lex.hpp&quot;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>Token lex_name<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>Token lex_number<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>Token lex_operator<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isoperator<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span> valid_chars <span class="op">=</span> <span class="st">&quot;+*-/!=&lt;&gt;&quot;</span><span class="op">;</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> valid_chars<span class="op">.</span>find<span class="op">(</span>c<span class="op">)</span> <span class="op">!=</span> <span class="bu">std::</span>string::npos<span class="op">;</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>Token extract_next_token<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isspace<span class="op">(</span>c<span class="op">));</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>stream<span class="op">)</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>end_of_file_token<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">};</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;(&#39;</span><span class="op">)</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>open_paren_token<span class="op">,</span> <span class="st">&quot;(&quot;</span><span class="op">};</span></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>close_paren_token<span class="op">,</span> <span class="st">&quot;)&quot;</span><span class="op">};</span></span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a>    stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_name<span class="op">(</span>stream<span class="op">);</span></span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_number<span class="op">(</span>stream<span class="op">);</span></span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb64-33"><a href="#cb64-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_operator<span class="op">(</span>stream<span class="op">);</span></span>
<span id="cb64-34"><a href="#cb64-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-35"><a href="#cb64-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;unrecognised character&quot;</span><span class="op">};</span></span>
<span id="cb64-36"><a href="#cb64-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb64-37"><a href="#cb64-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-38"><a href="#cb64-38" aria-hidden="true" tabindex="-1"></a>Token lex_name<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-39"><a href="#cb64-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb64-40"><a href="#cb64-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb64-41"><a href="#cb64-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb64-42"><a href="#cb64-42" aria-hidden="true" tabindex="-1"></a>        name<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb64-43"><a href="#cb64-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-44"><a href="#cb64-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">)</span></span>
<span id="cb64-45"><a href="#cb64-45" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb64-46"><a href="#cb64-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-47"><a href="#cb64-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> name<span class="op">};</span></span>
<span id="cb64-48"><a href="#cb64-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb64-49"><a href="#cb64-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-50"><a href="#cb64-50" aria-hidden="true" tabindex="-1"></a>Token lex_number<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-51"><a href="#cb64-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb64-52"><a href="#cb64-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string number<span class="op">;</span></span>
<span id="cb64-53"><a href="#cb64-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb64-54"><a href="#cb64-54" aria-hidden="true" tabindex="-1"></a>        number<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb64-55"><a href="#cb64-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-56"><a href="#cb64-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">)</span></span>
<span id="cb64-57"><a href="#cb64-57" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb64-58"><a href="#cb64-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-59"><a href="#cb64-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>number_token<span class="op">,</span> number<span class="op">};</span></span>
<span id="cb64-60"><a href="#cb64-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb64-61"><a href="#cb64-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-62"><a href="#cb64-62" aria-hidden="true" tabindex="-1"></a>Token lex_operator<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-63"><a href="#cb64-63" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb64-64"><a href="#cb64-64" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string op<span class="op">;</span></span>
<span id="cb64-65"><a href="#cb64-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>stream<span class="op">.</span>get<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb64-66"><a href="#cb64-66" aria-hidden="true" tabindex="-1"></a>        op<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb64-67"><a href="#cb64-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-68"><a href="#cb64-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stream<span class="op">)</span></span>
<span id="cb64-69"><a href="#cb64-69" aria-hidden="true" tabindex="-1"></a>        stream<span class="op">.</span>unget<span class="op">();</span></span>
<span id="cb64-70"><a href="#cb64-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-71"><a href="#cb64-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> op<span class="op">};</span></span>
<span id="cb64-72"><a href="#cb64-72" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="lex.hpp-1">lex.hpp</h2>
<div class="sourceCode" id="cb65"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_16_LEX_HPP</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_16_LEX_HPP</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>Token extract_next_token<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> stream<span class="op">);</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="main.cpp-16">main.cpp</h2>
<p>Suggested reading order: main.cpp (beginning), token.hpp, token.cpp,
main.cpp (rest) lex.hpp and lex.cpp have not changed.</p>
<p>We now have a Token type that we can use to represent tokens in our
program. At the moment, we can create Tokens, pass them to and from
functions, and access the type and value members. However, given two
tokens x and y, we cannot do x == y or x != y, and we cannot output a
token with std::cout &lt;&lt; x, nor read one with std::cin &gt;&gt; x.
In this chapter we’ll fix those issues.</p>
<p>In order to make those operations legal, we need to define how those
operators work when given Tokens. Just like functions, operators take
parameters and give a result, so it comes as no surprise that overloaded
operators are actually functions written with nicer syntax. The name of
the function is operator@@, where @@ is the operator in question.</p>
<p>(BUG: At the moment, there is no mention of overloading up to this
point. This should probably be handled at least briefly before operator
overloading comes to play. I can’t think of where to put it,
though.)</p>
<p>Go to token.hpp for some examples.</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lex.hpp&quot;</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// There are no implicit conversions to string happening here: the &gt;&gt; and &lt;&lt;</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// operators really are taking Tokens.</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    Token tok<span class="op">;</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Notice that this way of reading means we never see the end_of_file_token.</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is just for demonstration purposes; soon we&#39;ll have a better way to</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do this.</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> tok<span class="op">)</span></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> tok <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Error: &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Unknown error.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="token.cpp">token.cpp</h2>
<div class="sourceCode" id="cb67"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">// A minor detail: here we use the fact we split token and lex into header and</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co">// source files.  This means we can have both source files include both header</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="co">// files, and everything will work fine.  Had we not split them this way, we</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="co">// would have to first have to include everything declared and defined in token,</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="co">// and then everything defined in lex, or the other way around.  Try rewriting</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="co">// the program like that, and see where you run into issues.</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lex.hpp&quot;</span></span></code></pre></div>
<p>The definitions are just as close to function definitions. The syntax
is new, but conceptually these are all things we could have written
normal functions for before.</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lhs<span class="op">.</span>type <span class="op">==</span> rhs<span class="op">.</span>type <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value <span class="op">==</span> rhs<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We could repeat the logic here, but defining it in terms of operator== is</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// simpler.</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>istream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&gt;&gt;(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">,</span> Token<span class="op">&amp;</span> tok<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We already have extract_next_token, so there&#39;s no need to reimplement all</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that functionality.</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If the stream is already in a failed state we don&#39;t want to modify tok.</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is<span class="op">)</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>        tok <span class="op">=</span> extract_next_token<span class="op">(</span>is<span class="op">);</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> is<span class="op">;</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We could use the print_token code here, and the compiler would have
no issue with it. However, we are used to the &gt;&gt; and &lt;&lt;
operators being symmetrical: if we have defined each, it would be nice
if reading using &gt;&gt; and then writing using &lt;&lt; would return
similar results.</p>
<p>In the case of tokens, this isn’t particularly convenient: printing
them is mostly intended for debugging, and then we want to have full
information about each token. In the next lesson we’ll look at a more
elaborate lexer which will replace both extract_next_token and
operator&gt;&gt;, and then we’ll define operator&lt;&lt; as we like
it.</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> tok<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="token.hpp-1">token.hpp</h2>
<div class="sourceCode" id="cb70"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_16_TOKEN_HPP</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_16_TOKEN_HPP</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> open_paren_token <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> close_paren_token <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> name_token <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> number_token <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> end_of_file_token <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> type<span class="op">;</span></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string value<span class="op">;</span></span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>As token.hpp is a header file, we don’t define the operator overloads
yet. However, we do want the other files to be aware of them, so we do
need to declare them.</p>
<p>Treat the operator declarations just as function declarations with a
funny name. You have less freedom when defining operators: for example,
you can’t change the number of parameters willy-nilly, but the body may
do anything a function may do.</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>istream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&gt;&gt;(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">,</span> Token<span class="op">&amp;</span> tok<span class="op">);</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">);</span></span></code></pre></div>
<p>Now go to token.cpp to see how things are implemented.</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-17---member-functions">Chapter 17 - Member
Functions</h1>
<h2 id="lexer.cpp">lexer.cpp</h2>
<div class="sourceCode" id="cb73"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lexer.hpp&quot;</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="co">// We keep this helper function around: it doesn&#39;t need any class data so it</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="co">// doesn&#39;t make sense to make it a member function.</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isoperator<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span> valid_chars <span class="op">=</span> <span class="st">&quot;+*-/!=&lt;&gt;&quot;</span><span class="op">;</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> valid_chars<span class="op">.</span>find<span class="op">(</span>c<span class="op">)</span> <span class="op">!=</span> <span class="bu">std::</span>string::npos<span class="op">;</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We need to define all those functions we declared Lexer to have. We
again use the scope resolution operator, now to specify that we are
indeed defining a member function of Lexer, not a normal function of the
same name.</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co">// We&#39;ve already initialized current_position, so we don&#39;t have to do anything</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="co">// about that in our constructor.  On the other hand, we get the value for</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="co">// input_stream from a parameter, and we&#39;d like to initialize it.  Furthermore,</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="co">// being a reference, input_stream cannot be default-constructed, and so we use</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="co">// the constructor-initializer.  (Even if we could have used an assignment, a</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span class="co">// constructor-initializer is neater, and may be faster.)</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span>Lexer<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">)</span> <span class="op">:</span> input_stream<span class="op">(</span>is<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="co">// The : starts the constructor-initializer, then input_stream(is) binds</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a><span class="co">// input_stream to is, and finally {} is the empty constructor body.</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a><span class="co">// This function looks much like extract_next_token.  However, we don&#39;t have to</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a><span class="co">// pass the stream around explicitly; instead, we can use input_stream from any</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="co">// of our member functions.  When inside a member function, calling another</span></span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a><span class="co">// member function without specifying what instance we are calling it on calls</span></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a><span class="co">// it on the current instance.</span></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>extract<span class="op">()</span> <span class="op">{</span></span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>    ignore_whitespace<span class="op">();</span></span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>end_of_file_token<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">};</span></span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb74-24"><a href="#cb74-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_name<span class="op">();</span></span>
<span id="cb74-25"><a href="#cb74-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb74-26"><a href="#cb74-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_number<span class="op">();</span></span>
<span id="cb74-27"><a href="#cb74-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb74-28"><a href="#cb74-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_operator<span class="op">();</span></span>
<span id="cb74-29"><a href="#cb74-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-30"><a href="#cb74-30" aria-hidden="true" tabindex="-1"></a>    ignore<span class="op">();</span></span>
<span id="cb74-31"><a href="#cb74-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-32"><a href="#cb74-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;(&#39;</span><span class="op">)</span></span>
<span id="cb74-33"><a href="#cb74-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>open_paren_token<span class="op">,</span> <span class="st">&quot;(&quot;</span><span class="op">};</span></span>
<span id="cb74-34"><a href="#cb74-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span></span>
<span id="cb74-35"><a href="#cb74-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>close_paren_token<span class="op">,</span> <span class="st">&quot;)&quot;</span><span class="op">};</span></span>
<span id="cb74-36"><a href="#cb74-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-37"><a href="#cb74-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;unrecognised character&quot;</span><span class="op">};</span></span>
<span id="cb74-38"><a href="#cb74-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-39"><a href="#cb74-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-40"><a href="#cb74-40" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span>Position Lexer<span class="op">::</span>get_position<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb74-41"><a href="#cb74-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current_position<span class="op">;</span></span>
<span id="cb74-42"><a href="#cb74-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-43"><a href="#cb74-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-44"><a href="#cb74-44" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span><span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb74-45"><a href="#cb74-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Here we again use the function-like form of conversion.  This is because</span></span>
<span id="cb74-46"><a href="#cb74-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// operator bool() in std::istream is also explicit, and so simply returning</span></span>
<span id="cb74-47"><a href="#cb74-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// would give us an error.</span></span>
<span id="cb74-48"><a href="#cb74-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dt">bool</span><span class="op">(</span>input_stream<span class="op">);</span></span>
<span id="cb74-49"><a href="#cb74-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-50"><a href="#cb74-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-51"><a href="#cb74-51" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Lexer<span class="op">::</span>peek<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb74-52"><a href="#cb74-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::istream doesn&#39;t allow us to peek(c) like it allowed us to get(c), so</span></span>
<span id="cb74-53"><a href="#cb74-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we have to work around this.</span></span>
<span id="cb74-54"><a href="#cb74-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-55"><a href="#cb74-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">// peek returns an int, so that we can check for end-of-file.</span></span>
<span id="cb74-56"><a href="#cb74-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> input_stream<span class="op">.</span>peek<span class="op">();</span></span>
<span id="cb74-57"><a href="#cb74-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::char_traits&lt;char&gt;::eof returns the value that indicates an end of file.</span></span>
<span id="cb74-58"><a href="#cb74-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="bu">std::</span>char_traits<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;::</span>eof<span class="op">())</span></span>
<span id="cb74-59"><a href="#cb74-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb74-60"><a href="#cb74-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Otherwise, the implicit conversion is guaranteed to be safe.</span></span>
<span id="cb74-61"><a href="#cb74-61" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb74-62"><a href="#cb74-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb74-63"><a href="#cb74-63" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-64"><a href="#cb74-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-65"><a href="#cb74-65" aria-hidden="true" tabindex="-1"></a><span class="co">// ignore is where the work regarding position tracking happens.  This isn&#39;t the</span></span>
<span id="cb74-66"><a href="#cb74-66" aria-hidden="true" tabindex="-1"></a><span class="co">// most efficient way of implementing a Lexer; we almost always call peek double</span></span>
<span id="cb74-67"><a href="#cb74-67" aria-hidden="true" tabindex="-1"></a><span class="co">// the number of times necessary.  However, at this point the gain in safety is</span></span>
<span id="cb74-68"><a href="#cb74-68" aria-hidden="true" tabindex="-1"></a><span class="co">// worth the drop in performance.</span></span>
<span id="cb74-69"><a href="#cb74-69" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Lexer<span class="op">::</span>ignore<span class="op">()</span> <span class="op">{</span></span>
<span id="cb74-70"><a href="#cb74-70" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb74-71"><a href="#cb74-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb74-72"><a href="#cb74-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">{</span><span class="st">&quot;ignoring past end of file&quot;</span><span class="op">};</span></span>
<span id="cb74-73"><a href="#cb74-73" aria-hidden="true" tabindex="-1"></a>    input_stream<span class="op">.</span>ignore<span class="op">();</span></span>
<span id="cb74-74"><a href="#cb74-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb74-75"><a href="#cb74-75" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>line <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb74-76"><a href="#cb74-76" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>column <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb74-77"><a href="#cb74-77" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb74-78"><a href="#cb74-78" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>column <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb74-79"><a href="#cb74-79" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb74-80"><a href="#cb74-80" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-81"><a href="#cb74-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-82"><a href="#cb74-82" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Lexer<span class="op">::</span>get<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb74-83"><a href="#cb74-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb74-84"><a href="#cb74-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb74-85"><a href="#cb74-85" aria-hidden="true" tabindex="-1"></a>    ignore<span class="op">();</span></span>
<span id="cb74-86"><a href="#cb74-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb74-87"><a href="#cb74-87" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-88"><a href="#cb74-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-89"><a href="#cb74-89" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Lexer<span class="op">::</span>ignore_whitespace<span class="op">()</span> <span class="op">{</span></span>
<span id="cb74-90"><a href="#cb74-90" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb74-91"><a href="#cb74-91" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isspace<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb74-92"><a href="#cb74-92" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb74-93"><a href="#cb74-93" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-94"><a href="#cb74-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-95"><a href="#cb74-95" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_name<span class="op">()</span> <span class="op">{</span></span>
<span id="cb74-96"><a href="#cb74-96" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb74-97"><a href="#cb74-97" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb74-98"><a href="#cb74-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb74-99"><a href="#cb74-99" aria-hidden="true" tabindex="-1"></a>        name<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb74-100"><a href="#cb74-100" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb74-101"><a href="#cb74-101" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb74-102"><a href="#cb74-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-103"><a href="#cb74-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> name<span class="op">};</span></span>
<span id="cb74-104"><a href="#cb74-104" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-105"><a href="#cb74-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-106"><a href="#cb74-106" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_number<span class="op">()</span> <span class="op">{</span></span>
<span id="cb74-107"><a href="#cb74-107" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb74-108"><a href="#cb74-108" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string number<span class="op">;</span></span>
<span id="cb74-109"><a href="#cb74-109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb74-110"><a href="#cb74-110" aria-hidden="true" tabindex="-1"></a>        number<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb74-111"><a href="#cb74-111" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb74-112"><a href="#cb74-112" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb74-113"><a href="#cb74-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-114"><a href="#cb74-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>number_token<span class="op">,</span> number<span class="op">};</span></span>
<span id="cb74-115"><a href="#cb74-115" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-116"><a href="#cb74-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-117"><a href="#cb74-117" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_operator<span class="op">()</span> <span class="op">{</span></span>
<span id="cb74-118"><a href="#cb74-118" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb74-119"><a href="#cb74-119" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string op<span class="op">;</span></span>
<span id="cb74-120"><a href="#cb74-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> isoperator<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb74-121"><a href="#cb74-121" aria-hidden="true" tabindex="-1"></a>        op<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb74-122"><a href="#cb74-122" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb74-123"><a href="#cb74-123" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb74-124"><a href="#cb74-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-125"><a href="#cb74-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> op<span class="op">};</span></span>
<span id="cb74-126"><a href="#cb74-126" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-127"><a href="#cb74-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-128"><a href="#cb74-128" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!(</span>Lexer <span class="at">const</span><span class="op">&amp;</span> lex<span class="op">)</span> <span class="op">{</span></span>
<span id="cb74-129"><a href="#cb74-129" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!</span><span class="dt">bool</span><span class="op">(</span>lex<span class="op">);</span></span>
<span id="cb74-130"><a href="#cb74-130" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-131"><a href="#cb74-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-132"><a href="#cb74-132" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb74-133"><a href="#cb74-133" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lhs<span class="op">.</span>line <span class="op">==</span> rhs<span class="op">.</span>line <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>column <span class="op">==</span> rhs<span class="op">.</span>column<span class="op">;</span></span>
<span id="cb74-134"><a href="#cb74-134" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-135"><a href="#cb74-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-136"><a href="#cb74-136" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb74-137"><a href="#cb74-137" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb74-138"><a href="#cb74-138" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-139"><a href="#cb74-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-140"><a href="#cb74-140" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Lexer<span class="op">::</span>Position pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb74-141"><a href="#cb74-141" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;(line: &quot;</span> <span class="op">&lt;&lt;</span> pos<span class="op">.</span>line <span class="op">&lt;&lt;</span> <span class="st">&quot;, column:&quot;</span> <span class="op">&lt;&lt;</span> pos<span class="op">.</span>column <span class="op">&lt;&lt;</span> <span class="st">&quot;)&quot;</span><span class="op">;</span></span>
<span id="cb74-142"><a href="#cb74-142" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb74-143"><a href="#cb74-143" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>With the lexer implemented, let’s look at the resulting main
function.</p>
<h2 id="lexer.hpp">lexer.hpp</h2>
<div class="sourceCode" id="cb75"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_17_LEXER_HPP</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_17_LEXER_HPP</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span></code></pre></div>
<p>The definition of Lexer is going to have many similarities with the
definition of Token; members are declared much the same way, for
instance. We’ll comment only on the things that change.</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Lexer <span class="op">{</span></span></code></pre></div>
<p>The first change is that apart from member variables, our lexer will
have member functions. We’ve seen member functions before, though we
never called them that: when we have an std::vector&lt;int&gt; v and
call v.size(), we are calling a member function; same when we have an
std::string str and call str.find(‘x’). Member functions take parameters
just like normal functions do, but they have an extra implicit
parameter: when we call v.size(), size can implicitly access everything
in v.</p>
<p>Let’s decide what member functions we want: we’d like to be able to
create a Lexer from an std::istream&amp;, get the next token, check if
there are any more tokens, and get the current position in the
input.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// So far, we have been using the Token{x, y} syntax to specify the members</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// one-by-one; with our Lexer, this won&#39;t work because we don&#39;t want people</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to know about most of our members.  We will define a constructor: this is</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a special member function which is called when we create an instance.  It</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// has no return type and has the same name as the type it is a constructor</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// of.</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can also choose whether to require the constructor to be called</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// explicitly or implicitly.  The default is implicit; this means that if we</span></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// have a function taking a Lexer, we can give it an std::istream&amp; and a</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// temporary Lexer will be automatically created.  We probably don&#39;t want</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this, so let&#39;s disable it here.</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> Lexer<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">);</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can now use Lexer lex{std::cin}; to create a lexer called lex.</span></span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// However, we cannot use Lexer lex; anymore.  Usually, a constructor taking</span></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// no parameters (also called a default-constructor) is auto-generated by</span></span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the compiler, but defining your own constructor disables that.  We could</span></span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// define a custom default-constructor by defining a constructor that can be</span></span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// called with no arguments, but we choose not to do so here.</span></span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-21"><a href="#cb77-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We don&#39;t want our Lexer to be copyable: in fact, if it were easy to do,</span></span>
<span id="cb77-22"><a href="#cb77-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we&#39;d like the lexer to be the only thing that could do anything with the</span></span>
<span id="cb77-23"><a href="#cb77-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// input stream we gave it.  Unfortunately, there&#39;s no easy way of achieving</span></span>
<span id="cb77-24"><a href="#cb77-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that, but making sure we don&#39;t accidentally copy our lexer is a good</span></span>
<span id="cb77-25"><a href="#cb77-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// begin.</span></span>
<span id="cb77-26"><a href="#cb77-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb77-27"><a href="#cb77-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// In order to prohibit copying, we delete the copy-constructor.  This is a</span></span>
<span id="cb77-28"><a href="#cb77-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// constructor that takes a reference to a const instance of the type it is</span></span>
<span id="cb77-29"><a href="#cb77-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// constructing.  A deletion looks much like a declaration:</span></span>
<span id="cb77-30"><a href="#cb77-30" aria-hidden="true" tabindex="-1"></a>    Lexer<span class="op">(</span>Lexer <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb77-31"><a href="#cb77-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Of course, there will be no accompanying definition.</span></span>
<span id="cb77-32"><a href="#cb77-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-33"><a href="#cb77-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Extract and return the next token.</span></span>
<span id="cb77-34"><a href="#cb77-34" aria-hidden="true" tabindex="-1"></a>    Token extract<span class="op">();</span></span></code></pre></div>
<p>We’d like to return position information, but how do we best do this?
We could define separate get_line and get_column member functions, but
the two are likely to be used together, so we can create another type to
store a line and a column.</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Position <span class="op">{</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> line<span class="op">,</span> column<span class="op">;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Getting the position shouldn&#39;t change the state of our lexer.  This means</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that even if we have a Lexer const, we should still be able to call</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// get_position on it.  We can allow this by adding const to the end of the</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// member function declaration; this is part of the function&#39;s type.  The</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// compiler will check that we don&#39;t accidentally modify the Lexer.</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Whether you add const or not is a question much like whether to add it</span></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// when you pass something by reference.  Adding it gives you more freedom</span></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to use this function, but means the function can do less.  As more</span></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// features are introduced the choice becomes harder, but for now we can</span></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// make fairly good judgements about what does and doesn&#39;t modify the lexer.</span></span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>    Position get_position<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is a conversion operator.  We will use it much like we used</span></span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::cin&#39;s conversion to bool: if it returns true, it means we can</span></span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// extract at least one more token.</span></span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The explicit here means that it will only trigger when we really want a</span></span>
<span id="cb78-23"><a href="#cb78-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// bool.  Normally, bools can convert to ints, and so we could accidentally</span></span>
<span id="cb78-24"><a href="#cb78-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// end up converting our Lexer to an int.  If we ever did that it would</span></span>
<span id="cb78-25"><a href="#cb78-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// probably be a mistake, so we don&#39;t allow it.</span></span>
<span id="cb78-26"><a href="#cb78-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>We’ve now defined our external interface. However, we’ve not yet
defined any of the data our Lexer contains. We don’t want people to rely
on how we represent our state, so we mark it as private. This means that
most functions can’t access it: at the moment, only Lexer’s member
functions are given access. We can expand this access by making a
function a friend, but we don’t need to yet.</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is how we specify that all members past this point are private.  If</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we want to give everyone access again, we can instead say &quot;public:&quot;.</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// public is the default access level for types declared as structs.  We</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// could have used &quot;class&quot; instead of &quot;struct&quot; when defining Lexer, which</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// would make the default access level private.</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span></code></pre></div>
<p>So far we’ve been using fairly short and non-descriptive names for
our variables. For things local to a short function, that may be
acceptable: seeing how it is defined is often enough to judge. However,
once a variable is used in many places, it pays off to give it a clearer
name. Notice that we’ve already been doing this with function names.</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Remember how once a reference was bound to something, we couldn&#39;t rebind</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it?  A consequence of this is that we cannot assign a Lexer to another</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Lexer.  We can still copy it, though.</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>istream<span class="op">&amp;</span> input_stream<span class="op">;</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can specify initial values for our members.  Here it matters little,</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// as we could have just written them in the constructor, but this way is</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// easier if there are multiple constructors.</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>    Position current_position<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span></code></pre></div>
<p>Sometimes we want a member function to be private. In this case, we’d
like to have a few helper functions to work with the input stream for
us. All further operations will be in terms of these functions.</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Try to get the next character in the stream: if that succeeds, assign it</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to c, otherwise leave c unchanged.  Return whether it succeeded.</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> peek<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ignore a single character.</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is an interesting case when it comes to const.  Strictly speaking,</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// as we have a reference to an std::istream, we could make this function</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// const.  Intuitively, we can see that it does modify the lexer state, so</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we don&#39;t mark it const.</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// More formally, if two functions don&#39;t modify an instance&#39;s state, the</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// order in which we call them should not matter.  Were ignore to be const,</span></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we would expect that given a Lexer lex, lex.ignore(); lex.peek(c); would</span></span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// give the same result as lex.peek(c); lex.ignore();.  However, the two are</span></span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// obviously different, so marking ignore as const would be misleading.</span></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> ignore<span class="op">();</span></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Same as peek_raw, except that the character is also dropped.</span></span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> get<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">);</span></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ignore characters until a non-whitespace character is encountered.</span></span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> ignore_whitespace<span class="op">();</span></span></code></pre></div>
<p>Our old lex_* functions will be here, too, and do the same thing as
before.</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>    Token lex_name<span class="op">();</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    Token lex_number<span class="op">();</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    Token lex_operator<span class="op">();</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="co">// This goes well together with operator bool; it lets us do !lex.</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!(</span>Lexer <span class="at">const</span><span class="op">&amp;</span> lex<span class="op">);</span></span></code></pre></div>
<p>A little more about the :: operator. It is called the scope
resolution operator, and we use it when we want to specify a name that
is defined within some other entity. We’ve seen that types can contain a
variety of members. When we want to say “member X of type Y”, we write
“Y::X”. This doesn’t always make sense: for example, you can’t access a
member variable without an instance. However, it does make sense for
types.</p>
<p>Thus, when we wish to use the Position type, which we defined inside
Lexer, we simply say Lexer::Position.</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">);</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">);</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Lexer<span class="op">::</span>Position pos<span class="op">);</span></span></code></pre></div>
<p>Continue to lexer.cpp to see how we implement all this.</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="main.cpp-17">main.cpp</h2>
<p>Suggested reading order: main.cpp (beginning), lexer.hpp, lexer.cpp,
main.cpp (rest) token.hpp and token.cpp have undergone minor changes:
operator&gt;&gt; is gone, and operator&lt;&lt; works as print_token did
in chapter 15.</p>
<p>Now let’s take a closer look at how we read tokens. In practice, just
being able to extract tokens one by one often isn’t good enough: we want
to track position information, look a few tokens ahead or behind, and
all that without caring about how it is implemented.</p>
<p>The solution that comes to mind with the tools we have so far is to
make a type Lexer that contains all the necessary data, and then write a
bunch of functions that take it by reference and update the state. This
would work, but there’s two big issues with it:</p>
<ul>
<li>Having to always explicitly pass around our Lexer would get tedious.
We already have this problem with passing the std::istream&amp; around
to our lex functions; this would make it worse.</li>
<li>There’s no easy way to specify what is part of the public interface
and what is an implementation detail. We may want to keep a vector of
parsed tokens, but we don’t want people to write code relying on that
vector; what if we later decide to use a different data structure for
it?</li>
</ul>
<p>We will still create a Lexer type, but we will avoid both of the
above issues using member functions. Take a look at lexer.hpp.</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lexer.hpp&quot;</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    Lexer lex<span class="op">{</span><span class="bu">std::</span>cin<span class="op">};</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>lex<span class="op">)</span> <span class="op">{</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We report the positions one past the end of tokens, not the starting</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ones.  There&#39;s a number of ways to change this, the simplest being to</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// make the position part of the token data, but it doesn&#39;t matter much</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// for the example.</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> tok <span class="op">=</span> lex<span class="op">.</span>extract<span class="op">();</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> pos <span class="op">=</span> lex<span class="op">.</span>get_position<span class="op">();</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> pos <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&lt;</span> tok <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Error: &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Unknown error.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb85-24"><a href="#cb85-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The main thing to take away from this chapter is that when we have a
type, there’s a nice syntax for defining functions that operate on this
type. We will use member functions extensively from now on: for now they
are easily rewritten as normal functions that take an extra reference
parameter, but we will see usages where the conversion isn’t quite as
simple.</p>
<p>Spend some time writing your own types. There’s quite a few
improvements that can be made to the lexer class: the position
information could be made more precise, and we could make things more
efficient. These things are not hard to fix, but add more complexity,
which is why I did not include them.</p>
<p>A bigger issue is the fact that Lexer is doing a little too much: it
handles position information and token retrieval all at once. It would
have been better if the Lexer only had to implement the extraction
functions, and a separate StreamWithPosition type would deal with the
rest. See if you can come up with a neat way of splitting the two.</p>
<p>By the way, as mentioned in lexer.hpp, both the struct and class
keywords can be used to define a type. I’ll use “struct” and “class”
interchangably when referring to types we define; just “type” is a more
generic term, as int is also a type</p>
<h2 id="token.cpp-1">token.cpp</h2>
<div class="sourceCode" id="cb86"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lhs<span class="op">.</span>type <span class="op">==</span> rhs<span class="op">.</span>type <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value <span class="op">==</span> rhs<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">)</span> <span class="op">{</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;{ &quot;</span><span class="op">;</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> open_paren_token<span class="op">)</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;open_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> close_paren_token<span class="op">)</span></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;close_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb86-18"><a href="#cb86-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> name_token<span class="op">)</span></span>
<span id="cb86-19"><a href="#cb86-19" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;name_token&quot;</span><span class="op">;</span></span>
<span id="cb86-20"><a href="#cb86-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> number_token<span class="op">)</span></span>
<span id="cb86-21"><a href="#cb86-21" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;number_token&quot;</span><span class="op">;</span></span>
<span id="cb86-22"><a href="#cb86-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> end_of_file_token<span class="op">)</span></span>
<span id="cb86-23"><a href="#cb86-23" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;end_of_file_token&quot;</span><span class="op">;</span></span>
<span id="cb86-24"><a href="#cb86-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-25"><a href="#cb86-25" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;, </span><span class="sc">\&quot;</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> tok<span class="op">.</span>value <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb86-26"><a href="#cb86-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb86-27"><a href="#cb86-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="token.hpp-2">token.hpp</h2>
<div class="sourceCode" id="cb87"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_17_TOKEN_HPP</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_17_TOKEN_HPP</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> open_paren_token <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> close_paren_token <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> name_token <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> number_token <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> end_of_file_token <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> type<span class="op">;</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string value<span class="op">;</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">);</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-18---recursion">Chapter 18 - Recursion</h1>
<h2 id="lexer.cpp-1">lexer.cpp</h2>
<div class="sourceCode" id="cb88"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lexer.hpp&quot;</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isoperator<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span> valid_chars <span class="op">=</span> <span class="st">&quot;+*-/!=&lt;&gt;&quot;</span><span class="op">;</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> valid_chars<span class="op">.</span>find<span class="op">(</span>c<span class="op">)</span> <span class="op">!=</span> <span class="bu">std::</span>string::npos<span class="op">;</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span>Lexer<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">)</span> <span class="op">:</span> input_stream<span class="op">(</span>is<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>extract<span class="op">()</span> <span class="op">{</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>    ignore_whitespace<span class="op">();</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>end_of_file_token<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">};</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_name<span class="op">();</span></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_number<span class="op">();</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_operator<span class="op">();</span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>    ignore<span class="op">();</span></span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;(&#39;</span><span class="op">)</span></span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>open_paren_token<span class="op">,</span> <span class="st">&quot;(&quot;</span><span class="op">};</span></span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span></span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>close_paren_token<span class="op">,</span> <span class="st">&quot;)&quot;</span><span class="op">};</span></span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;unrecognised character&quot;</span><span class="op">};</span></span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span>Position Lexer<span class="op">::</span>get_position<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current_position<span class="op">;</span></span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span><span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb88-41"><a href="#cb88-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dt">bool</span><span class="op">(</span>input_stream<span class="op">);</span></span>
<span id="cb88-42"><a href="#cb88-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-43"><a href="#cb88-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-44"><a href="#cb88-44" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Lexer<span class="op">::</span>peek<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb88-45"><a href="#cb88-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> input_stream<span class="op">.</span>peek<span class="op">();</span></span>
<span id="cb88-46"><a href="#cb88-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="bu">std::</span>char_traits<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;::</span>eof<span class="op">())</span></span>
<span id="cb88-47"><a href="#cb88-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb88-48"><a href="#cb88-48" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb88-49"><a href="#cb88-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb88-50"><a href="#cb88-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-51"><a href="#cb88-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-52"><a href="#cb88-52" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Lexer<span class="op">::</span>ignore<span class="op">()</span> <span class="op">{</span></span>
<span id="cb88-53"><a href="#cb88-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb88-54"><a href="#cb88-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb88-55"><a href="#cb88-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">{</span><span class="st">&quot;ignoring past end of file&quot;</span><span class="op">};</span></span>
<span id="cb88-56"><a href="#cb88-56" aria-hidden="true" tabindex="-1"></a>    input_stream<span class="op">.</span>ignore<span class="op">();</span></span>
<span id="cb88-57"><a href="#cb88-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-58"><a href="#cb88-58" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>line <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb88-59"><a href="#cb88-59" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>column <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb88-60"><a href="#cb88-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb88-61"><a href="#cb88-61" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>column <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb88-62"><a href="#cb88-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-63"><a href="#cb88-63" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-64"><a href="#cb88-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-65"><a href="#cb88-65" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Lexer<span class="op">::</span>get<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-66"><a href="#cb88-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb88-67"><a href="#cb88-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb88-68"><a href="#cb88-68" aria-hidden="true" tabindex="-1"></a>    ignore<span class="op">();</span></span>
<span id="cb88-69"><a href="#cb88-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb88-70"><a href="#cb88-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-71"><a href="#cb88-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-72"><a href="#cb88-72" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Lexer<span class="op">::</span>ignore_whitespace<span class="op">()</span> <span class="op">{</span></span>
<span id="cb88-73"><a href="#cb88-73" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb88-74"><a href="#cb88-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isspace<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb88-75"><a href="#cb88-75" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb88-76"><a href="#cb88-76" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-77"><a href="#cb88-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-78"><a href="#cb88-78" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_name<span class="op">()</span> <span class="op">{</span></span>
<span id="cb88-79"><a href="#cb88-79" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb88-80"><a href="#cb88-80" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb88-81"><a href="#cb88-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb88-82"><a href="#cb88-82" aria-hidden="true" tabindex="-1"></a>        name<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb88-83"><a href="#cb88-83" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb88-84"><a href="#cb88-84" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-85"><a href="#cb88-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-86"><a href="#cb88-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> name<span class="op">};</span></span>
<span id="cb88-87"><a href="#cb88-87" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-88"><a href="#cb88-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-89"><a href="#cb88-89" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_number<span class="op">()</span> <span class="op">{</span></span>
<span id="cb88-90"><a href="#cb88-90" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb88-91"><a href="#cb88-91" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string number<span class="op">;</span></span>
<span id="cb88-92"><a href="#cb88-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb88-93"><a href="#cb88-93" aria-hidden="true" tabindex="-1"></a>        number<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb88-94"><a href="#cb88-94" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb88-95"><a href="#cb88-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-96"><a href="#cb88-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-97"><a href="#cb88-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>number_token<span class="op">,</span> number<span class="op">};</span></span>
<span id="cb88-98"><a href="#cb88-98" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-99"><a href="#cb88-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-100"><a href="#cb88-100" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_operator<span class="op">()</span> <span class="op">{</span></span>
<span id="cb88-101"><a href="#cb88-101" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb88-102"><a href="#cb88-102" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string op<span class="op">;</span></span>
<span id="cb88-103"><a href="#cb88-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> isoperator<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb88-104"><a href="#cb88-104" aria-hidden="true" tabindex="-1"></a>        op<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb88-105"><a href="#cb88-105" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb88-106"><a href="#cb88-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-107"><a href="#cb88-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-108"><a href="#cb88-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> op<span class="op">};</span></span>
<span id="cb88-109"><a href="#cb88-109" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-110"><a href="#cb88-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-111"><a href="#cb88-111" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!(</span>Lexer <span class="at">const</span><span class="op">&amp;</span> lex<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-112"><a href="#cb88-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!</span><span class="dt">bool</span><span class="op">(</span>lex<span class="op">);</span></span>
<span id="cb88-113"><a href="#cb88-113" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-114"><a href="#cb88-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-115"><a href="#cb88-115" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-116"><a href="#cb88-116" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lhs<span class="op">.</span>line <span class="op">==</span> rhs<span class="op">.</span>line <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>column <span class="op">==</span> rhs<span class="op">.</span>column<span class="op">;</span></span>
<span id="cb88-117"><a href="#cb88-117" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-118"><a href="#cb88-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-119"><a href="#cb88-119" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-120"><a href="#cb88-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb88-121"><a href="#cb88-121" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-122"><a href="#cb88-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-123"><a href="#cb88-123" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Lexer<span class="op">::</span>Position pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-124"><a href="#cb88-124" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;(line: &quot;</span> <span class="op">&lt;&lt;</span> pos<span class="op">.</span>line <span class="op">&lt;&lt;</span> <span class="st">&quot;, column:&quot;</span> <span class="op">&lt;&lt;</span> pos<span class="op">.</span>column <span class="op">&lt;&lt;</span> <span class="st">&quot;)&quot;</span><span class="op">;</span></span>
<span id="cb88-125"><a href="#cb88-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb88-126"><a href="#cb88-126" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="lexer.hpp-1">lexer.hpp</h2>
<div class="sourceCode" id="cb89"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_18_LEXER_HPP</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_18_LEXER_HPP</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Lexer <span class="op">{</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> Lexer<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">);</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>    Lexer<span class="op">(</span>Lexer <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>    Token extract<span class="op">();</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Position <span class="op">{</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> line<span class="op">,</span> column<span class="op">;</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>    Position get_position<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>istream<span class="op">&amp;</span> input_stream<span class="op">;</span></span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a>    Position current_position<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> peek<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> ignore<span class="op">();</span></span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> get<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">);</span></span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-34"><a href="#cb89-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> ignore_whitespace<span class="op">();</span></span>
<span id="cb89-35"><a href="#cb89-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-36"><a href="#cb89-36" aria-hidden="true" tabindex="-1"></a>    Token lex_name<span class="op">();</span></span>
<span id="cb89-37"><a href="#cb89-37" aria-hidden="true" tabindex="-1"></a>    Token lex_number<span class="op">();</span></span>
<span id="cb89-38"><a href="#cb89-38" aria-hidden="true" tabindex="-1"></a>    Token lex_operator<span class="op">();</span></span>
<span id="cb89-39"><a href="#cb89-39" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb89-40"><a href="#cb89-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-41"><a href="#cb89-41" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!(</span>Lexer <span class="at">const</span><span class="op">&amp;</span> lex<span class="op">);</span></span>
<span id="cb89-42"><a href="#cb89-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-43"><a href="#cb89-43" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">);</span></span>
<span id="cb89-44"><a href="#cb89-44" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">);</span></span>
<span id="cb89-45"><a href="#cb89-45" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Lexer<span class="op">::</span>Position pos<span class="op">);</span></span>
<span id="cb89-46"><a href="#cb89-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-47"><a href="#cb89-47" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="main.cpp-18">main.cpp</h2>
<p>Suggested reading order: main.cpp (beginning), parser.hpp,
parser.cpp, main.cpp (rest)</p>
<p>The tokens and lexer have not changed.</p>
<p>We now have a lexer, and it gives us some (though not perfect)
position information, so let’s implement a simple parser on top of it.
At the moment, we don’t have any tools to store the tree, so we’ll start
by simply recognizing the structure and pretty-printing it back with
some annotations. To be specific, we’ll take</p>
<p><code>(+ (* 5 x) 3)</code></p>
<p>and print</p>
<p><code>function call:</code></p>
<p><code>function:</code></p>
<p><code>name: +</code></p>
<p><code>arguments:</code></p>
<p><code>function call:</code></p>
<p><code>function:</code></p>
<p><code>name: *</code></p>
<p><code>arguments:</code></p>
<p><code>number: 5</code></p>
<p><code>name: x</code></p>
<p><code>number: 3</code></p>
<p>Take a look at parser.hpp to see the interface.</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parser.hpp&quot;</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="cf">try</span> <span class="op">{</span></span></code></pre></div>
<p>Up to now we’ve been reading all standard input and then writing
everything to standard output. We could do this again, but we’d much
rather be able to enter an expression on a single line and then
immediately get the pretty-printed version.</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We need a variable to store the current line in.</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string line<span class="op">;</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This extracts a line from std::cin into line, and then returns std::cin</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// so that we can check whether we&#39;ve hit the end of file yet or not.</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>getline<span class="op">(</span><span class="bu">std::</span>cin<span class="op">,</span> line<span class="op">))</span> <span class="op">{</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We now have a string that we would like to parse, but our parser</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// expects an std::istream&amp;.  Fortunately, the standard library has an</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// std::istringstream class that can be treated as an istream, and</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// allows us to store an arbitrary string in it.</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>istringstream line_stream<span class="op">(</span>line<span class="op">);</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We could just call parse_and_reprint_expression, but that would</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// terminate the program if the expression was invalid.</span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">//</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Recall the semantics of an exception.  A throw indicates that the</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// program has entered an invalid state, and a catch sets it back into a</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// valid state it can continue from.  If it wasn&#39;t possible to parse a</span></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// line of input, we can just notify the user of this and then continue</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// with the next line, so we add a catch and do exactly that.</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>            parse_and_reprint_expression<span class="op">(</span>line_stream<span class="op">);</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Notice that we&#39;re catching more than strictly necessary here.</span></span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// We&#39;re almost at the point where this can be fixed.</span></span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb91-32"><a href="#cb91-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Error: &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb91-33"><a href="#cb91-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb91-34"><a href="#cb91-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb91-35"><a href="#cb91-35" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb91-36"><a href="#cb91-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Unknown error.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb91-37"><a href="#cb91-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb91-38"><a href="#cb91-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The next chapter will introduce two important C++ features:
inheritance and pointers. We’ll look at how we can represent a tree with
nodes of different types, and how we can then use virtual functions to
perform operations on the tree.</p>
<p>After that, we’ll go back and refactor the resulting code. I’ve
already mentioned many of the issues as we came across them: the longer
we keep them in, the more of a pain they will be as we continue, so
we’ll invest some time into weeding them out.</p>
<h2 id="parser.cpp">parser.cpp</h2>
<div class="sourceCode" id="cb92"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parser.hpp&quot;</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lexer.hpp&quot;</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a><span class="co">// As we saw in the examples, an expression can contain another expression.</span></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a><span class="co">// We already have a function for parsing expressions, so we may as well use</span></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a><span class="co">// that for the subexpression, too.  We can&#39;t use parse_and_reprint_expression</span></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a><span class="co">// directly for this purpose, as we can&#39;t give it a lexer and indentation level,</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a><span class="co">// so we introduce a helper function that does track that data.</span></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a><span class="co">// We return bool to indicate whether parsing an expression succeded.  We don&#39;t</span></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a><span class="co">// throw an exception for that, as it isn&#39;t an error situation: when we&#39;re</span></span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a><span class="co">// parsing the arguments to a function, at some point we&#39;ll run into the closing</span></span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a><span class="co">// brace, which means we have all the arguments and continue.</span></span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> p_expression<span class="op">(</span>Lexer<span class="op">&amp;</span> lexer<span class="op">,</span> <span class="dt">int</span> indent<span class="op">);</span></span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-20"><a href="#cb92-20" aria-hidden="true" tabindex="-1"></a><span class="co">// Print the specified number of spaces.</span></span>
<span id="cb92-21"><a href="#cb92-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> indent_to<span class="op">(</span><span class="dt">int</span> indent<span class="op">);</span></span>
<span id="cb92-22"><a href="#cb92-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-23"><a href="#cb92-23" aria-hidden="true" tabindex="-1"></a><span class="co">// Helper functions for printing.</span></span>
<span id="cb92-24"><a href="#cb92-24" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> pretty_print_name<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> name<span class="op">,</span> <span class="dt">int</span> indent<span class="op">);</span></span>
<span id="cb92-25"><a href="#cb92-25" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> pretty_print_number<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> number<span class="op">,</span> <span class="dt">int</span> indent<span class="op">);</span></span>
<span id="cb92-26"><a href="#cb92-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-27"><a href="#cb92-27" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> parse_and_reprint_expression<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> input<span class="op">)</span> <span class="op">{</span></span>
<span id="cb92-28"><a href="#cb92-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Why bother with this function, if we could just let people call p_call?</span></span>
<span id="cb92-29"><a href="#cb92-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Encapsulation.  This function specifies only that which is really</span></span>
<span id="cb92-30"><a href="#cb92-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// necessary: we need an istream to read input from.  Details like</span></span>
<span id="cb92-31"><a href="#cb92-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// indentation and the lexer are exactly that: details, and whoever is using</span></span>
<span id="cb92-32"><a href="#cb92-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the parser likely won&#39;t care about them.  Splitting things this way makes</span></span>
<span id="cb92-33"><a href="#cb92-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the calling code easier to understand.</span></span>
<span id="cb92-34"><a href="#cb92-34" aria-hidden="true" tabindex="-1"></a>    Lexer lexer<span class="op">(</span>input<span class="op">);</span></span>
<span id="cb92-35"><a href="#cb92-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-36"><a href="#cb92-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>lexer<span class="op">)</span></span>
<span id="cb92-37"><a href="#cb92-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: stream not in good state.&quot;</span><span class="op">};</span></span>
<span id="cb92-38"><a href="#cb92-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-39"><a href="#cb92-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> success <span class="op">=</span> p_expression<span class="op">(</span>lexer<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb92-40"><a href="#cb92-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>success<span class="op">)</span></span>
<span id="cb92-41"><a href="#cb92-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: no expression found.&quot;</span><span class="op">};</span></span>
<span id="cb92-42"><a href="#cb92-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When the lexer reaches the end of file, it will emit an eof token
before going into a bad state. It would be convenient to check only for
this token, instead of also having to check the lexer state all the
time.</p>
<p>Unfortunately, there may be a bug in the code leading to one of these
functions being called when the eof has already been extracted. If we
don’t check the state, such a bug would lead to failures when we try to
use the values, which could happen significantly later than the read
itself, and which would likely be hard to fix.</p>
<p>To detect such programmer errors, we can use the standard assert
facility. The syntax is like a function call:</p>
<p><code>assert(expression);</code></p>
<p>If the expression evaluates to true, nothing happens. However, if the
expression is false, the program will exit and an error message will be
displayed.</p>
<p>assert may look like a function, but it isn’t one. There is, for
example, a way to disabling asserts, so that the statement is ignored
entirely and the expression is not evaluated at all.</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> indent_to<span class="op">(</span><span class="dt">int</span> indent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> indent<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">.</span>put<span class="op">(</span><span class="ch">&#39; &#39;</span><span class="op">);</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> pretty_print_name<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> name<span class="op">,</span> <span class="dt">int</span> indent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    indent_to<span class="op">(</span>indent<span class="op">);</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;name: &quot;</span> <span class="op">&lt;&lt;</span> name <span class="op">&lt;&lt;</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> pretty_print_number<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> number<span class="op">,</span> <span class="dt">int</span> indent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>    indent_to<span class="op">(</span>indent<span class="op">);</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;number: &quot;</span> <span class="op">&lt;&lt;</span> number <span class="op">&lt;&lt;</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Parsing a function call involves quite a bit more work than other</span></span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a><span class="co">// expressions, so we make a separate function for that.</span></span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> p_function_call<span class="op">(</span>Lexer<span class="op">&amp;</span> lexer<span class="op">,</span> <span class="dt">int</span> indent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a>    indent_to<span class="op">(</span>indent<span class="op">);</span></span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;function call:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb93-23"><a href="#cb93-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-24"><a href="#cb93-24" aria-hidden="true" tabindex="-1"></a>    indent_to<span class="op">(</span>indent<span class="op">+</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb93-25"><a href="#cb93-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;function:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb93-26"><a href="#cb93-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-27"><a href="#cb93-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> success <span class="op">=</span> p_expression<span class="op">(</span>lexer<span class="op">,</span> indent<span class="op">+</span><span class="dv">8</span><span class="op">);</span></span>
<span id="cb93-28"><a href="#cb93-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>success<span class="op">)</span></span>
<span id="cb93-29"><a href="#cb93-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: expected function.&quot;</span><span class="op">};</span></span>
<span id="cb93-30"><a href="#cb93-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-31"><a href="#cb93-31" aria-hidden="true" tabindex="-1"></a>    indent_to<span class="op">(</span>indent<span class="op">+</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb93-32"><a href="#cb93-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;arguments: </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb93-33"><a href="#cb93-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The parsing already does everything we want, so we simply need to loop</span></span>
<span id="cb93-34"><a href="#cb93-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// until we have no more expressions.</span></span>
<span id="cb93-35"><a href="#cb93-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>p_expression<span class="op">(</span>lexer<span class="op">,</span> indent<span class="op">+</span><span class="dv">8</span><span class="op">));</span></span>
<span id="cb93-36"><a href="#cb93-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb93-37"><a href="#cb93-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-38"><a href="#cb93-38" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> p_expression<span class="op">(</span>Lexer<span class="op">&amp;</span> lexer<span class="op">,</span> <span class="dt">int</span> indent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb93-39"><a href="#cb93-39" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb93-40"><a href="#cb93-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-41"><a href="#cb93-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> token <span class="op">=</span> lexer<span class="op">.</span>extract<span class="op">();</span></span>
<span id="cb93-42"><a href="#cb93-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-43"><a href="#cb93-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// First check for cases where there is no expression.</span></span>
<span id="cb93-44"><a href="#cb93-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> end_of_file_token<span class="op">)</span></span>
<span id="cb93-45"><a href="#cb93-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: expected an expression.&quot;</span><span class="op">};</span></span>
<span id="cb93-46"><a href="#cb93-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-47"><a href="#cb93-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> close_paren_token<span class="op">)</span></span>
<span id="cb93-48"><a href="#cb93-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb93-49"><a href="#cb93-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-50"><a href="#cb93-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// From here on, we know that if the token type is valid, the return value</span></span>
<span id="cb93-51"><a href="#cb93-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// will be true.</span></span>
<span id="cb93-52"><a href="#cb93-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> name_token<span class="op">)</span></span>
<span id="cb93-53"><a href="#cb93-53" aria-hidden="true" tabindex="-1"></a>        pretty_print_name<span class="op">(</span>token<span class="op">.</span>value<span class="op">,</span> indent<span class="op">);</span></span>
<span id="cb93-54"><a href="#cb93-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> number_token<span class="op">)</span></span>
<span id="cb93-55"><a href="#cb93-55" aria-hidden="true" tabindex="-1"></a>        pretty_print_number<span class="op">(</span>token<span class="op">.</span>value<span class="op">,</span> indent<span class="op">);</span></span>
<span id="cb93-56"><a href="#cb93-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> open_paren_token<span class="op">)</span></span>
<span id="cb93-57"><a href="#cb93-57" aria-hidden="true" tabindex="-1"></a>        p_function_call<span class="op">(</span>lexer<span class="op">,</span> indent<span class="op">);</span></span>
<span id="cb93-58"><a href="#cb93-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb93-59"><a href="#cb93-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">{</span><span class="st">&quot;Unrecognised token type.&quot;</span><span class="op">};</span></span>
<span id="cb93-60"><a href="#cb93-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-61"><a href="#cb93-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb93-62"><a href="#cb93-62" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We’ve now implemented a very simple parser! Note that the way we’re
doing things is hardly optimal. For one, we’re mixing code does that
parsing with code that does output. This is ugly, but means we can get
the parsing logic written before we look at the features necessary to
store the program that we parsed. Take a look at main.cpp, where we use
the parser.</p>
<h2 id="parser.hpp">parser.hpp</h2>
<div class="sourceCode" id="cb94"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_18_PARSER_HPP</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_18_PARSER_HPP</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span></code></pre></div>
<p>This header can be extremely simple. Unlike in the case of a Lexer,
we don’t need to give the parser observable state. Thanks to this, a
simple function will do, and so we only expose that, leaving the details
to the implementation.</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Read an expression and re-print it in a pretty way.</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> parse_and_reprint_expression<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> input<span class="op">);</span></span></code></pre></div>
<p>Continue to parser.cpp to see how we implement this.</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="token.cpp-2">token.cpp</h2>
<div class="sourceCode" id="cb97"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lhs<span class="op">.</span>type <span class="op">==</span> rhs<span class="op">.</span>type <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value <span class="op">==</span> rhs<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">)</span> <span class="op">{</span></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;{ &quot;</span><span class="op">;</span></span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> open_paren_token<span class="op">)</span></span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;open_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> close_paren_token<span class="op">)</span></span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;close_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> name_token<span class="op">)</span></span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;name_token&quot;</span><span class="op">;</span></span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> number_token<span class="op">)</span></span>
<span id="cb97-21"><a href="#cb97-21" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;number_token&quot;</span><span class="op">;</span></span>
<span id="cb97-22"><a href="#cb97-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> end_of_file_token<span class="op">)</span></span>
<span id="cb97-23"><a href="#cb97-23" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;end_of_file_token&quot;</span><span class="op">;</span></span>
<span id="cb97-24"><a href="#cb97-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-25"><a href="#cb97-25" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;, </span><span class="sc">\&quot;</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> tok<span class="op">.</span>value <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb97-26"><a href="#cb97-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb97-27"><a href="#cb97-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="token.hpp-3">token.hpp</h2>
<div class="sourceCode" id="cb98"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_18_TOKEN_HPP</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_18_TOKEN_HPP</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> open_paren_token <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> close_paren_token <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> name_token <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> number_token <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> end_of_file_token <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> type<span class="op">;</span></span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string value<span class="op">;</span></span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb98-20"><a href="#cb98-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">);</span></span>
<span id="cb98-21"><a href="#cb98-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-22"><a href="#cb98-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-19---inheritance">Chapter 19 - Inheritance</h1>
<h2 id="expression.hpp">expression.hpp</h2>
<div class="sourceCode" id="cb99"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_19_EXPRESSION_HPP</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_19_EXPRESSION_HPP</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a><span class="co">// The basic syntax for defining the expression class is the same.</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Expression <span class="op">{</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// There&#39;s two things here that we haven&#39;t seen before.</span></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// First of all, the function is prefixed with virtual.  This means that the</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// function may be overriden by a derived class.  If we have a NumberExpr</span></span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// class that derives from Expression, and a reference to Expression that</span></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// actually refers to a NumberExpr object, a lookup will be done at runtime,</span></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and the override defined in NumberExpr will be called instead.  Had the</span></span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// function not been virtual, the print defined in Expression would be</span></span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// called.</span></span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Secondly, we have the = 0 at the end.  This means that print is a pure</span></span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// virtual function: it does not have to be defined in Expression.  On the</span></span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// other hand, it also means that we cannot create an instance of</span></span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Expression.  If we want to create an Expression, we have to make a</span></span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// derived type, define an override for print, and then create an instance</span></span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// of that.</span></span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// How is Expression still useful?  We can still make references to it.</span></span>
<span id="cb99-26"><a href="#cb99-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Take a look at the operator&lt;&lt; defined below for an example.</span></span>
<span id="cb99-27"><a href="#cb99-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb99-28"><a href="#cb99-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-29"><a href="#cb99-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// One of the things we&#39;d like to be able to do with Expressions is to</span></span>
<span id="cb99-30"><a href="#cb99-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// destroy them; if we kept them around forever, we&#39;d be using much more</span></span>
<span id="cb99-31"><a href="#cb99-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// memory than we really need.  Sometimes, we&#39;ll want to destroy an</span></span>
<span id="cb99-32"><a href="#cb99-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Expression without knowing what kind of Expression it is.</span></span>
<span id="cb99-33"><a href="#cb99-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb99-34"><a href="#cb99-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Whenever an object is destroyed, the destructor is run.  If we want to be</span></span>
<span id="cb99-35"><a href="#cb99-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// able to destroy objects as above, we must make the destructor virtual.</span></span>
<span id="cb99-36"><a href="#cb99-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// In this case, that&#39;s the only thing we need to change, so we can give it</span></span>
<span id="cb99-37"><a href="#cb99-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the default implementation.</span></span>
<span id="cb99-38"><a href="#cb99-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Expression<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb99-39"><a href="#cb99-39" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb99-40"><a href="#cb99-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-41"><a href="#cb99-41" aria-hidden="true" tabindex="-1"></a><span class="co">// Let&#39;s take a look at an example use of Expression.  We know that expr is</span></span>
<span id="cb99-42"><a href="#cb99-42" aria-hidden="true" tabindex="-1"></a><span class="co">// going to be a reference to an object of some derived type.  We also know that</span></span>
<span id="cb99-43"><a href="#cb99-43" aria-hidden="true" tabindex="-1"></a><span class="co">// that type must implement print for there to be an instance of it.  We can</span></span>
<span id="cb99-44"><a href="#cb99-44" aria-hidden="true" tabindex="-1"></a><span class="co">// thus conclude that this is safe, but we can&#39;t know which version will be</span></span>
<span id="cb99-45"><a href="#cb99-45" aria-hidden="true" tabindex="-1"></a><span class="co">// called until runtime -- and that&#39;s by design.</span></span>
<span id="cb99-46"><a href="#cb99-46" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Expression <span class="at">const</span><span class="op">&amp;</span> expr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb99-47"><a href="#cb99-47" aria-hidden="true" tabindex="-1"></a>    expr<span class="op">.</span>print<span class="op">(</span>os<span class="op">);</span></span>
<span id="cb99-48"><a href="#cb99-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb99-49"><a href="#cb99-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Go on to number_expr.hpp.</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="lexer.cpp-2">lexer.cpp</h2>
<div class="sourceCode" id="cb101"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lexer.hpp&quot;</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isoperator<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span> valid_chars <span class="op">=</span> <span class="st">&quot;+*-/!=&lt;&gt;&quot;</span><span class="op">;</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> valid_chars<span class="op">.</span>find<span class="op">(</span>c<span class="op">)</span> <span class="op">!=</span> <span class="bu">std::</span>string::npos<span class="op">;</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span>Lexer<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">)</span> <span class="op">:</span> input_stream<span class="op">(</span>is<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>extract<span class="op">()</span> <span class="op">{</span></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>    ignore_whitespace<span class="op">();</span></span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>end_of_file_token<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">};</span></span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_name<span class="op">();</span></span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_number<span class="op">();</span></span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_operator<span class="op">();</span></span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a>    ignore<span class="op">();</span></span>
<span id="cb101-27"><a href="#cb101-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-28"><a href="#cb101-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;(&#39;</span><span class="op">)</span></span>
<span id="cb101-29"><a href="#cb101-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>open_paren_token<span class="op">,</span> <span class="st">&quot;(&quot;</span><span class="op">};</span></span>
<span id="cb101-30"><a href="#cb101-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span></span>
<span id="cb101-31"><a href="#cb101-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>close_paren_token<span class="op">,</span> <span class="st">&quot;)&quot;</span><span class="op">};</span></span>
<span id="cb101-32"><a href="#cb101-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-33"><a href="#cb101-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;unrecognised character&quot;</span><span class="op">};</span></span>
<span id="cb101-34"><a href="#cb101-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-35"><a href="#cb101-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-36"><a href="#cb101-36" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span>Position Lexer<span class="op">::</span>get_position<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb101-37"><a href="#cb101-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current_position<span class="op">;</span></span>
<span id="cb101-38"><a href="#cb101-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-39"><a href="#cb101-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-40"><a href="#cb101-40" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span><span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb101-41"><a href="#cb101-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dt">bool</span><span class="op">(</span>input_stream<span class="op">);</span></span>
<span id="cb101-42"><a href="#cb101-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-43"><a href="#cb101-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-44"><a href="#cb101-44" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Lexer<span class="op">::</span>peek<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb101-45"><a href="#cb101-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> input_stream<span class="op">.</span>peek<span class="op">();</span></span>
<span id="cb101-46"><a href="#cb101-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="bu">std::</span>char_traits<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;::</span>eof<span class="op">())</span></span>
<span id="cb101-47"><a href="#cb101-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb101-48"><a href="#cb101-48" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb101-49"><a href="#cb101-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb101-50"><a href="#cb101-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-51"><a href="#cb101-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-52"><a href="#cb101-52" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Lexer<span class="op">::</span>ignore<span class="op">()</span> <span class="op">{</span></span>
<span id="cb101-53"><a href="#cb101-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb101-54"><a href="#cb101-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb101-55"><a href="#cb101-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">{</span><span class="st">&quot;ignoring past end of file&quot;</span><span class="op">};</span></span>
<span id="cb101-56"><a href="#cb101-56" aria-hidden="true" tabindex="-1"></a>    input_stream<span class="op">.</span>ignore<span class="op">();</span></span>
<span id="cb101-57"><a href="#cb101-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-58"><a href="#cb101-58" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>line <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb101-59"><a href="#cb101-59" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>column <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb101-60"><a href="#cb101-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb101-61"><a href="#cb101-61" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>column <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb101-62"><a href="#cb101-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb101-63"><a href="#cb101-63" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-64"><a href="#cb101-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-65"><a href="#cb101-65" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Lexer<span class="op">::</span>get<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-66"><a href="#cb101-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb101-67"><a href="#cb101-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb101-68"><a href="#cb101-68" aria-hidden="true" tabindex="-1"></a>    ignore<span class="op">();</span></span>
<span id="cb101-69"><a href="#cb101-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb101-70"><a href="#cb101-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-71"><a href="#cb101-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-72"><a href="#cb101-72" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Lexer<span class="op">::</span>ignore_whitespace<span class="op">()</span> <span class="op">{</span></span>
<span id="cb101-73"><a href="#cb101-73" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb101-74"><a href="#cb101-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isspace<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb101-75"><a href="#cb101-75" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb101-76"><a href="#cb101-76" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-77"><a href="#cb101-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-78"><a href="#cb101-78" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_name<span class="op">()</span> <span class="op">{</span></span>
<span id="cb101-79"><a href="#cb101-79" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb101-80"><a href="#cb101-80" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb101-81"><a href="#cb101-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb101-82"><a href="#cb101-82" aria-hidden="true" tabindex="-1"></a>        name<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb101-83"><a href="#cb101-83" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb101-84"><a href="#cb101-84" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb101-85"><a href="#cb101-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-86"><a href="#cb101-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> name<span class="op">};</span></span>
<span id="cb101-87"><a href="#cb101-87" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-88"><a href="#cb101-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-89"><a href="#cb101-89" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_number<span class="op">()</span> <span class="op">{</span></span>
<span id="cb101-90"><a href="#cb101-90" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb101-91"><a href="#cb101-91" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string number<span class="op">;</span></span>
<span id="cb101-92"><a href="#cb101-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb101-93"><a href="#cb101-93" aria-hidden="true" tabindex="-1"></a>        number<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb101-94"><a href="#cb101-94" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb101-95"><a href="#cb101-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb101-96"><a href="#cb101-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-97"><a href="#cb101-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>number_token<span class="op">,</span> number<span class="op">};</span></span>
<span id="cb101-98"><a href="#cb101-98" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-99"><a href="#cb101-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-100"><a href="#cb101-100" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_operator<span class="op">()</span> <span class="op">{</span></span>
<span id="cb101-101"><a href="#cb101-101" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb101-102"><a href="#cb101-102" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string op<span class="op">;</span></span>
<span id="cb101-103"><a href="#cb101-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> isoperator<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb101-104"><a href="#cb101-104" aria-hidden="true" tabindex="-1"></a>        op<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb101-105"><a href="#cb101-105" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb101-106"><a href="#cb101-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb101-107"><a href="#cb101-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-108"><a href="#cb101-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> op<span class="op">};</span></span>
<span id="cb101-109"><a href="#cb101-109" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-110"><a href="#cb101-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-111"><a href="#cb101-111" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!(</span>Lexer <span class="at">const</span><span class="op">&amp;</span> lex<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-112"><a href="#cb101-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!</span><span class="dt">bool</span><span class="op">(</span>lex<span class="op">);</span></span>
<span id="cb101-113"><a href="#cb101-113" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-114"><a href="#cb101-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-115"><a href="#cb101-115" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-116"><a href="#cb101-116" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lhs<span class="op">.</span>line <span class="op">==</span> rhs<span class="op">.</span>line <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>column <span class="op">==</span> rhs<span class="op">.</span>column<span class="op">;</span></span>
<span id="cb101-117"><a href="#cb101-117" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-118"><a href="#cb101-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-119"><a href="#cb101-119" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-120"><a href="#cb101-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb101-121"><a href="#cb101-121" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-122"><a href="#cb101-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-123"><a href="#cb101-123" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Lexer<span class="op">::</span>Position pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-124"><a href="#cb101-124" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;(line: &quot;</span> <span class="op">&lt;&lt;</span> pos<span class="op">.</span>line <span class="op">&lt;&lt;</span> <span class="st">&quot;, column:&quot;</span> <span class="op">&lt;&lt;</span> pos<span class="op">.</span>column <span class="op">&lt;&lt;</span> <span class="st">&quot;)&quot;</span><span class="op">;</span></span>
<span id="cb101-125"><a href="#cb101-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb101-126"><a href="#cb101-126" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="lexer.hpp-2">lexer.hpp</h2>
<div class="sourceCode" id="cb102"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_19_LEXER_HPP</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_19_LEXER_HPP</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Lexer <span class="op">{</span></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> Lexer<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">);</span></span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a>    Lexer<span class="op">(</span>Lexer <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a>    Token extract<span class="op">();</span></span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Position <span class="op">{</span></span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> line<span class="op">,</span> column<span class="op">;</span></span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true" tabindex="-1"></a>    Position get_position<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>istream<span class="op">&amp;</span> input_stream<span class="op">;</span></span>
<span id="cb102-25"><a href="#cb102-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-26"><a href="#cb102-26" aria-hidden="true" tabindex="-1"></a>    Position current_position<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb102-27"><a href="#cb102-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-28"><a href="#cb102-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> peek<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb102-29"><a href="#cb102-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-30"><a href="#cb102-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> ignore<span class="op">();</span></span>
<span id="cb102-31"><a href="#cb102-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-32"><a href="#cb102-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> get<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">);</span></span>
<span id="cb102-33"><a href="#cb102-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-34"><a href="#cb102-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> ignore_whitespace<span class="op">();</span></span>
<span id="cb102-35"><a href="#cb102-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-36"><a href="#cb102-36" aria-hidden="true" tabindex="-1"></a>    Token lex_name<span class="op">();</span></span>
<span id="cb102-37"><a href="#cb102-37" aria-hidden="true" tabindex="-1"></a>    Token lex_number<span class="op">();</span></span>
<span id="cb102-38"><a href="#cb102-38" aria-hidden="true" tabindex="-1"></a>    Token lex_operator<span class="op">();</span></span>
<span id="cb102-39"><a href="#cb102-39" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb102-40"><a href="#cb102-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-41"><a href="#cb102-41" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!(</span>Lexer <span class="at">const</span><span class="op">&amp;</span> lex<span class="op">);</span></span>
<span id="cb102-42"><a href="#cb102-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-43"><a href="#cb102-43" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">);</span></span>
<span id="cb102-44"><a href="#cb102-44" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">);</span></span>
<span id="cb102-45"><a href="#cb102-45" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Lexer<span class="op">::</span>Position pos<span class="op">);</span></span>
<span id="cb102-46"><a href="#cb102-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-47"><a href="#cb102-47" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="list_expr.cpp">list_expr.cpp</h2>
<div class="sourceCode" id="cb103"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;list_expr.hpp&quot;</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ListExpr<span class="op">::</span>add<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> expr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>    elements<span class="op">.</span>push_back<span class="op">(</span>expr<span class="op">);</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ListExpr<span class="op">::</span>print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ignoring the extra trouble done to not print the trailing space, this is</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// surprisingly straightforward code.  We don&#39;t need to check the types of</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// anything; we can simply use the virtual print function and it&#39;ll do the</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// right thing depending on the type of the element.</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>    out <span class="op">&lt;&lt;</span> <span class="ch">&#39;(&#39;</span><span class="op">;</span></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> first <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> e <span class="op">:</span> elements<span class="op">)</span> <span class="op">{</span></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>first<span class="op">)</span></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a>            out <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a>        e<span class="op">-&gt;</span>print<span class="op">(</span>out<span class="op">);</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>    out <span class="op">&lt;&lt;</span> <span class="ch">&#39;)&#39;</span><span class="op">;</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now let’s take a look at how it all fits together in main.cpp.</p>
<h2 id="list_expr.hpp">list_expr.hpp</h2>
<div class="sourceCode" id="cb104"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_19_LIST_EXPR_HPP</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_19_LIST_EXPR_HPP</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span></code></pre></div>
<p>We’d like our ListExpr to store a vector of expressions. However, a
vector stores instances of the type it contains, and we want can’t make
an instance of Expression – nor do we want to, for that matter. We’d
like to be able to put NumberExprs, VariableExprs, and ListExprs into
whatever data structure we use.</p>
<p>In order to do this we introduce pointers. We won’t store the object
itself: instead we’ll create an object somewhere and then store a
pointer to it in the vector. You could see such a pointer as an iterator
to a collection that only has one element: it isn’t the object itself,
but we can access the object through it. Alternatively, you can see the
pointer as a reference which we can reassign at will.</p>
<p>An important question that comes up is how we’ll make sure the object
we create exists as long as we want it to, and no longer. If we make a
local and then store a pointer to it, it will be destroyed once we exit
the function, and the pointer will be invalid. On the other hand, we
somehow have to make sure that once we no longer have a use for the
object, it gets cleaned up.</p>
<p>First, though, let’s take a look at how to create an object. For this
purpose we will use the std::make_shared function template. For
example,</p>
<p><code>std::make_shared&lt;NumberExpr&gt;(x)</code></p>
<p>This will construct a NumberExpr with value x, and then return a
pointer to the object. The pointer will have type
std::shared_ptr&lt;NumberExpr&gt;, which will be convertible to
std::shared_ptr&lt;Expression&gt;.</p>
<p>Apart from creating our object, make_shared will also create a
counter for the number of shared_ptrs that point to it. Every time we
copy a pointer that counter will be incremented, while every time we
destroy one it will be decremented. Once the counter reaches zero, our
object will be destroyed; this is what we want, as we don’t want an
object we can’t access lying around.</p>
<p>Note that there are cases when objects become unreachable, but are
kept alive: if A has a shared_ptr to B, and B has a shared_ptr to A,
neither will be destroyed, even if the rest of our program cannot access
them.</p>
<p>Also note that seeing as shared_ptr handles the destruction of the
object, the object has to have been created in a way that is compatible
with how it destroys things. This won’t be a problem for us yet, as
make_shared is the only way we know to make pointers, but it’s worth
keeping in mind if you experiment.</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ListExpr <span class="op">:</span> <span class="kw">public</span> Expression <span class="op">{</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This may look strange, but is simply a vector of pointers to Expressions.</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;&gt;</span> elements<span class="op">;</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We&#39;ll want to add expressions to the vector one by one.</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> add<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> expr<span class="op">);</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Now that we can represent the tree, let’s make the parser create it.
Go on to parser.hpp.</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="main.cpp-19">main.cpp</h2>
<p>Suggested reading order: main.cpp (beginning), expression.hpp,
number_expr.hpp, variable_expr.hpp, list_expr.hpp, parser.hpp,
parser.cpp, number.cpp, variable.cpp, call.cpp, main.cpp (rest)</p>
<p>We’ve already seen that every object in C++ must have a type. We’d
like to make an Expression type that can represent any kind of
expression we can parse. However, there’s no single representation of an
Expression: it might be a number, or a variable name, or a list of other
expressions. We could go the same route as we went with Token, adding an
int to keep track of what kind of expression we’re working with; while
this would work, it would involve reserving space for all three
possibilities, and we’d have to be extra careful about which possibility
we are currently in.</p>
<p>Instead, we’ll have the Expression type which will only define what
must be possible to do with an expression; it won’t define how that
expression is represented, or how the operations are implemented. Each
of the three kinds of expressions we saw will then get their own,
distinct type, but will inherit from the common Expression type. The
compiler will enforce that they define the operations we left undefined
in Expression, and we will be able to treat them as if they were
Expressions. In particular, we will be able to make a reference to an
Expression that actually refers to an instance of one of the derived
types.</p>
<p>Take a look at expression.hpp to see how it is implemented.</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parser.hpp&quot;</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string line<span class="op">;</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>getline<span class="op">(</span><span class="bu">std::</span>cin<span class="op">,</span> line<span class="op">))</span> <span class="op">{</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>istringstream line_stream<span class="op">(</span>line<span class="op">);</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> ptr <span class="op">=</span> parse_expression<span class="op">(</span>line_stream<span class="op">);</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Recall the operator&lt;&lt; overload in expression.hpp; thanks to that,</span></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we can put this here.</span></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="op">*</span>ptr <span class="op">&lt;&lt;</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Error: &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Unknown error.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And that’s our parser! Note that the representation we chose for our
expressions is neither the only possible nor necessarily the best one;
it is simple and illustrates some important concepts, which is why I
chose it for the moment.</p>
<p>Even given this representation, there’s often better ways of doing
things. For one example, take a look at
http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil</p>
<h2 id="number_expr.cpp">number_expr.cpp</h2>
<div class="sourceCode" id="cb108"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;number_expr.hpp&quot;</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>NumberExpr<span class="op">::</span>NumberExpr<span class="op">(</span><span class="dt">int</span> value<span class="op">)</span> <span class="op">:</span> value<span class="op">(</span>value<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Implementing an override looks just like implementing a normal member function.</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> NumberExpr<span class="op">::</span>print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>    out <span class="op">&lt;&lt;</span> value<span class="op">;</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>variable_expr.cpp looks exactly the same, except for names, so feel
free to skip to list_expr.cpp.</p>
<h2 id="number_expr.hpp">number_expr.hpp</h2>
<div class="sourceCode" id="cb109"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_19_NUMBER_EXPR_HPP</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_19_NUMBER_EXPR_HPP</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="co">// This is the syntax for defining NumberExpr as a derived class of Expression.</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="co">// The public means that everyone can see this relationship: had we put private,</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a><span class="co">// then only NumberExpr would know that it derives from Expression.</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NumberExpr <span class="op">:</span> <span class="kw">public</span> Expression <span class="op">{</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The representation of a NumberExpr is simple: we just store the number.</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value<span class="op">;</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We require that a NumberExpr be created with a value.  Adding this</span></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// constructor means that a default one is not auto-generated, but this is</span></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// okay: we want every NumberExpr to have a value, anyway.</span></span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>    NumberExpr<span class="op">(</span><span class="dt">int</span> value<span class="op">);</span></span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We want to make instances of NumberExpr, so we have to override print.</span></span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// By using the override keyword we tell the compiler that we really do want</span></span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// an override, not an overload; if there was no function in Expression that</span></span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// our print overrides, we would get a compiler error.</span></span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Notice that we don&#39;t specify virtual here.  We could if we wanted, and it</span></span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// would not change anything: as the base class made it virtual, it will</span></span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// automatically be virtual in all derived classes.</span></span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>variable_expr.hpp is next, and almost the same as this file.</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="parser.cpp-1">parser.cpp</h2>
<div class="sourceCode" id="cb111"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parser.hpp&quot;</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lexer.hpp&quot;</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;number_expr.hpp&quot;</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;variable_expr.hpp&quot;</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;list_expr.hpp&quot;</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Here too we&#39;ll return the parsed expression.  Note that we aren&#39;t returning a</span></span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a><span class="co">// bool.  Instead, we&#39;ll use the fact that we can have a pointer pointing to</span></span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a><span class="co">// nothing.  p_expression will return a pointer to the parsed expression if</span></span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a><span class="co">// there is one, or a so-called null pointer if there isn&#39;t.</span></span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> p_expression<span class="op">(</span>Lexer<span class="op">&amp;</span> lexer<span class="op">);</span></span>
<span id="cb111-17"><a href="#cb111-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-18"><a href="#cb111-18" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> parse_expression<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> input<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-19"><a href="#cb111-19" aria-hidden="true" tabindex="-1"></a>    Lexer lexer<span class="op">(</span>input<span class="op">);</span></span>
<span id="cb111-20"><a href="#cb111-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-21"><a href="#cb111-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>lexer<span class="op">)</span></span>
<span id="cb111-22"><a href="#cb111-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: stream not in good state.&quot;</span><span class="op">};</span></span>
<span id="cb111-23"><a href="#cb111-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-24"><a href="#cb111-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> expr <span class="op">=</span> p_expression<span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb111-25"><a href="#cb111-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>expr<span class="op">)</span></span>
<span id="cb111-26"><a href="#cb111-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: no expression found.&quot;</span><span class="op">};</span></span>
<span id="cb111-27"><a href="#cb111-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-28"><a href="#cb111-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> expr<span class="op">;</span></span>
<span id="cb111-29"><a href="#cb111-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb111-30"><a href="#cb111-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-31"><a href="#cb111-31" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> p_function_call<span class="op">(</span>Lexer<span class="op">&amp;</span> lexer<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-32"><a href="#cb111-32" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb111-33"><a href="#cb111-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-34"><a href="#cb111-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> list <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>ListExpr<span class="op">&gt;();</span></span>
<span id="cb111-35"><a href="#cb111-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-36"><a href="#cb111-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">auto</span> ptr <span class="op">=</span> p_expression<span class="op">(</span>lexer<span class="op">))</span></span>
<span id="cb111-37"><a href="#cb111-37" aria-hidden="true" tabindex="-1"></a>        list<span class="op">-&gt;</span>add<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb111-38"><a href="#cb111-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-39"><a href="#cb111-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> list<span class="op">;</span></span>
<span id="cb111-40"><a href="#cb111-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb111-41"><a href="#cb111-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-42"><a href="#cb111-42" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> p_expression<span class="op">(</span>Lexer<span class="op">&amp;</span> lexer<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-43"><a href="#cb111-43" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb111-44"><a href="#cb111-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-45"><a href="#cb111-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> token <span class="op">=</span> lexer<span class="op">.</span>extract<span class="op">();</span></span>
<span id="cb111-46"><a href="#cb111-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-47"><a href="#cb111-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> end_of_file_token<span class="op">)</span></span>
<span id="cb111-48"><a href="#cb111-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: expected an expression.&quot;</span><span class="op">};</span></span>
<span id="cb111-49"><a href="#cb111-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-50"><a href="#cb111-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> close_paren_token<span class="op">)</span></span>
<span id="cb111-51"><a href="#cb111-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb111-52"><a href="#cb111-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-53"><a href="#cb111-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> name_token<span class="op">)</span></span>
<span id="cb111-54"><a href="#cb111-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>VariableExpr<span class="op">&gt;(</span>token<span class="op">.</span>value<span class="op">);</span></span>
<span id="cb111-55"><a href="#cb111-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> number_token<span class="op">)</span></span>
<span id="cb111-56"><a href="#cb111-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>NumberExpr<span class="op">&gt;(</span><span class="bu">std::</span>stoi<span class="op">(</span>token<span class="op">.</span>value<span class="op">));</span></span>
<span id="cb111-57"><a href="#cb111-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> open_paren_token<span class="op">)</span></span>
<span id="cb111-58"><a href="#cb111-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p_function_call<span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb111-59"><a href="#cb111-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-60"><a href="#cb111-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">{</span><span class="st">&quot;Unrecognised token type.&quot;</span><span class="op">};</span></span>
<span id="cb111-61"><a href="#cb111-61" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice how much simpler the parsing code became now that we don’t
have to worry about printing at the same time.</p>
<p>With this out of the way, let’s implement the printing. We’ll go for
a simpler format than in the previous chapter; feel free to expand it as
an exercises.</p>
<p>Next is number_expr.cpp.</p>
<h2 id="parser.hpp-1">parser.hpp</h2>
<div class="sourceCode" id="cb112"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_19_PARSER_HPP</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_19_PARSER_HPP</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Our function no longer does any printing, but it does need to return a</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a><span class="co">// pointer to the expression we parsed.</span></span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> parse_expression<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> input<span class="op">);</span></span></code></pre></div>
<p>Go on to parser.cpp.</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="token.cpp-3">token.cpp</h2>
<div class="sourceCode" id="cb114"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lhs<span class="op">.</span>type <span class="op">==</span> rhs<span class="op">.</span>type <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value <span class="op">==</span> rhs<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">)</span> <span class="op">{</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;{ &quot;</span><span class="op">;</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> open_paren_token<span class="op">)</span></span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;open_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> close_paren_token<span class="op">)</span></span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;close_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> name_token<span class="op">)</span></span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;name_token&quot;</span><span class="op">;</span></span>
<span id="cb114-20"><a href="#cb114-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> number_token<span class="op">)</span></span>
<span id="cb114-21"><a href="#cb114-21" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;number_token&quot;</span><span class="op">;</span></span>
<span id="cb114-22"><a href="#cb114-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> end_of_file_token<span class="op">)</span></span>
<span id="cb114-23"><a href="#cb114-23" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;end_of_file_token&quot;</span><span class="op">;</span></span>
<span id="cb114-24"><a href="#cb114-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-25"><a href="#cb114-25" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;, </span><span class="sc">\&quot;</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> tok<span class="op">.</span>value <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb114-26"><a href="#cb114-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb114-27"><a href="#cb114-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="token.hpp-4">token.hpp</h2>
<div class="sourceCode" id="cb115"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_19_TOKEN_HPP</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_19_TOKEN_HPP</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> open_paren_token <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> close_paren_token <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> name_token <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> number_token <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> end_of_file_token <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> type<span class="op">;</span></span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string value<span class="op">;</span></span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">);</span></span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="variable_expr.cpp">variable_expr.cpp</h2>
<div class="sourceCode" id="cb116"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;variable_expr.hpp&quot;</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>VariableExpr<span class="op">::</span>VariableExpr<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> name<span class="op">)</span> <span class="op">:</span> name<span class="op">(</span>name<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> VariableExpr<span class="op">::</span>print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>    out <span class="op">&lt;&lt;</span> name<span class="op">;</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="variable_expr.hpp">variable_expr.hpp</h2>
<div class="sourceCode" id="cb117"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_19_VARIABLE_EXPR_HPP</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_19_VARIABLE_EXPR_HPP</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VariableExpr <span class="op">:</span> <span class="kw">public</span> Expression <span class="op">{</span></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>    VariableExpr<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> name<span class="op">);</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Now take a look at list_expr.hpp, which is significantly more
interesting.</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="chapter-20---function-objects">Chapter 20 - Function
Objects</h1>
<h2 id="builtin_operations.cpp">builtin_operations.cpp</h2>
<div class="sourceCode" id="cb119"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;builtin_operations.hpp&quot;</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span></code></pre></div>
<p>We can implement the built-in functions in “normal” C++; we don’t
have to think about the language we’re implementing for this purpose.
We’ll just</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> builtin_add<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>accumulate<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>args<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>args<span class="op">),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> builtin_subtract<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>args<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>args<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>args<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> args<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">-</span> args<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;incorrect number of args to builtin_subtract&quot;</span><span class="op">};</span></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> builtin_multiply<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>accumulate<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>args<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>args<span class="op">),</span> <span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>multiplies<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{});</span></span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> builtin_divide<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb120-20"><a href="#cb120-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>args<span class="op">.</span>size<span class="op">()</span> <span class="op">!=</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb120-21"><a href="#cb120-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;incorrect number of args to builtin_divide&quot;</span><span class="op">};</span></span>
<span id="cb120-22"><a href="#cb120-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>args<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb120-23"><a href="#cb120-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;division by zero&quot;</span><span class="op">};</span></span>
<span id="cb120-24"><a href="#cb120-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> args<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">/</span> args<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb120-25"><a href="#cb120-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="builtin_operations.hpp">builtin_operations.hpp</h2>
<div class="sourceCode" id="cb121"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_20_BUILTIN_OPERATIONS_HPP</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_20_BUILTIN_OPERATIONS_HPP</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> builtin_add<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> args<span class="op">);</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> builtin_subtract<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> args<span class="op">);</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> builtin_multiply<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> args<span class="op">);</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> builtin_divide<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> args<span class="op">);</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="expression.hpp-1">expression.hpp</h2>
<div class="sourceCode" id="cb122"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_20_EXPRESSION_HPP</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_20_EXPRESSION_HPP</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;symbol_table.hpp&quot;</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Expression <span class="op">{</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">int</span> evaluate<span class="op">(</span>SymbolTable <span class="at">const</span><span class="op">&amp;</span> symbol_table<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Expression<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Expression <span class="at">const</span><span class="op">&amp;</span> expr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a>    expr<span class="op">.</span>print<span class="op">(</span>os<span class="op">);</span></span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb122-19"><a href="#cb122-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-20"><a href="#cb122-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="lexer.cpp-3">lexer.cpp</h2>
<div class="sourceCode" id="cb123"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lexer.hpp&quot;</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isoperator<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span> valid_chars <span class="op">=</span> <span class="st">&quot;+*-/!=&lt;&gt;&quot;</span><span class="op">;</span></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> valid_chars<span class="op">.</span>find<span class="op">(</span>c<span class="op">)</span> <span class="op">!=</span> <span class="bu">std::</span>string::npos<span class="op">;</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span>Lexer<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">)</span> <span class="op">:</span> input_stream<span class="op">(</span>is<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>extract<span class="op">()</span> <span class="op">{</span></span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a>    ignore_whitespace<span class="op">();</span></span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb123-16"><a href="#cb123-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb123-17"><a href="#cb123-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>end_of_file_token<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">};</span></span>
<span id="cb123-18"><a href="#cb123-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-19"><a href="#cb123-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb123-20"><a href="#cb123-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_name<span class="op">();</span></span>
<span id="cb123-21"><a href="#cb123-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb123-22"><a href="#cb123-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_number<span class="op">();</span></span>
<span id="cb123-23"><a href="#cb123-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>isoperator<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb123-24"><a href="#cb123-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lex_operator<span class="op">();</span></span>
<span id="cb123-25"><a href="#cb123-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-26"><a href="#cb123-26" aria-hidden="true" tabindex="-1"></a>    ignore<span class="op">();</span></span>
<span id="cb123-27"><a href="#cb123-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-28"><a href="#cb123-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;(&#39;</span><span class="op">)</span></span>
<span id="cb123-29"><a href="#cb123-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>open_paren_token<span class="op">,</span> <span class="st">&quot;(&quot;</span><span class="op">};</span></span>
<span id="cb123-30"><a href="#cb123-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span></span>
<span id="cb123-31"><a href="#cb123-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>close_paren_token<span class="op">,</span> <span class="st">&quot;)&quot;</span><span class="op">};</span></span>
<span id="cb123-32"><a href="#cb123-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-33"><a href="#cb123-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;unrecognised character&quot;</span><span class="op">};</span></span>
<span id="cb123-34"><a href="#cb123-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-35"><a href="#cb123-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-36"><a href="#cb123-36" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span>Position Lexer<span class="op">::</span>get_position<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb123-37"><a href="#cb123-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current_position<span class="op">;</span></span>
<span id="cb123-38"><a href="#cb123-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-39"><a href="#cb123-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-40"><a href="#cb123-40" aria-hidden="true" tabindex="-1"></a>Lexer<span class="op">::</span><span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb123-41"><a href="#cb123-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dt">bool</span><span class="op">(</span>input_stream<span class="op">);</span></span>
<span id="cb123-42"><a href="#cb123-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-43"><a href="#cb123-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-44"><a href="#cb123-44" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Lexer<span class="op">::</span>peek<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb123-45"><a href="#cb123-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> input_stream<span class="op">.</span>peek<span class="op">();</span></span>
<span id="cb123-46"><a href="#cb123-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="bu">std::</span>char_traits<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;::</span>eof<span class="op">())</span></span>
<span id="cb123-47"><a href="#cb123-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb123-48"><a href="#cb123-48" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb123-49"><a href="#cb123-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb123-50"><a href="#cb123-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-51"><a href="#cb123-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-52"><a href="#cb123-52" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Lexer<span class="op">::</span>ignore<span class="op">()</span> <span class="op">{</span></span>
<span id="cb123-53"><a href="#cb123-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb123-54"><a href="#cb123-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb123-55"><a href="#cb123-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">{</span><span class="st">&quot;ignoring past end of file&quot;</span><span class="op">};</span></span>
<span id="cb123-56"><a href="#cb123-56" aria-hidden="true" tabindex="-1"></a>    input_stream<span class="op">.</span>ignore<span class="op">();</span></span>
<span id="cb123-57"><a href="#cb123-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-58"><a href="#cb123-58" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>line <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb123-59"><a href="#cb123-59" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>column <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb123-60"><a href="#cb123-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb123-61"><a href="#cb123-61" aria-hidden="true" tabindex="-1"></a>        current_position<span class="op">.</span>column <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb123-62"><a href="#cb123-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb123-63"><a href="#cb123-63" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-64"><a href="#cb123-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-65"><a href="#cb123-65" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Lexer<span class="op">::</span>get<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-66"><a href="#cb123-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>peek<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb123-67"><a href="#cb123-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb123-68"><a href="#cb123-68" aria-hidden="true" tabindex="-1"></a>    ignore<span class="op">();</span></span>
<span id="cb123-69"><a href="#cb123-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb123-70"><a href="#cb123-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-71"><a href="#cb123-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-72"><a href="#cb123-72" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Lexer<span class="op">::</span>ignore_whitespace<span class="op">()</span> <span class="op">{</span></span>
<span id="cb123-73"><a href="#cb123-73" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb123-74"><a href="#cb123-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isspace<span class="op">(</span>c<span class="op">))</span></span>
<span id="cb123-75"><a href="#cb123-75" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb123-76"><a href="#cb123-76" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-77"><a href="#cb123-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-78"><a href="#cb123-78" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_name<span class="op">()</span> <span class="op">{</span></span>
<span id="cb123-79"><a href="#cb123-79" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb123-80"><a href="#cb123-80" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb123-81"><a href="#cb123-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isalpha<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb123-82"><a href="#cb123-82" aria-hidden="true" tabindex="-1"></a>        name<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb123-83"><a href="#cb123-83" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb123-84"><a href="#cb123-84" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb123-85"><a href="#cb123-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-86"><a href="#cb123-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> name<span class="op">};</span></span>
<span id="cb123-87"><a href="#cb123-87" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-88"><a href="#cb123-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-89"><a href="#cb123-89" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_number<span class="op">()</span> <span class="op">{</span></span>
<span id="cb123-90"><a href="#cb123-90" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb123-91"><a href="#cb123-91" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string number<span class="op">;</span></span>
<span id="cb123-92"><a href="#cb123-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isdigit<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb123-93"><a href="#cb123-93" aria-hidden="true" tabindex="-1"></a>        number<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb123-94"><a href="#cb123-94" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb123-95"><a href="#cb123-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb123-96"><a href="#cb123-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-97"><a href="#cb123-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>number_token<span class="op">,</span> number<span class="op">};</span></span>
<span id="cb123-98"><a href="#cb123-98" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-99"><a href="#cb123-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-100"><a href="#cb123-100" aria-hidden="true" tabindex="-1"></a>Token Lexer<span class="op">::</span>lex_operator<span class="op">()</span> <span class="op">{</span></span>
<span id="cb123-101"><a href="#cb123-101" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb123-102"><a href="#cb123-102" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string op<span class="op">;</span></span>
<span id="cb123-103"><a href="#cb123-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>peek<span class="op">(</span>c<span class="op">)</span> <span class="op">&amp;&amp;</span> isoperator<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb123-104"><a href="#cb123-104" aria-hidden="true" tabindex="-1"></a>        op<span class="op">.</span>push_back<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb123-105"><a href="#cb123-105" aria-hidden="true" tabindex="-1"></a>        ignore<span class="op">();</span></span>
<span id="cb123-106"><a href="#cb123-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb123-107"><a href="#cb123-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-108"><a href="#cb123-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>name_token<span class="op">,</span> op<span class="op">};</span></span>
<span id="cb123-109"><a href="#cb123-109" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-110"><a href="#cb123-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-111"><a href="#cb123-111" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!(</span>Lexer <span class="at">const</span><span class="op">&amp;</span> lex<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-112"><a href="#cb123-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!</span><span class="dt">bool</span><span class="op">(</span>lex<span class="op">);</span></span>
<span id="cb123-113"><a href="#cb123-113" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-114"><a href="#cb123-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-115"><a href="#cb123-115" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-116"><a href="#cb123-116" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lhs<span class="op">.</span>line <span class="op">==</span> rhs<span class="op">.</span>line <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>column <span class="op">==</span> rhs<span class="op">.</span>column<span class="op">;</span></span>
<span id="cb123-117"><a href="#cb123-117" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-118"><a href="#cb123-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-119"><a href="#cb123-119" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-120"><a href="#cb123-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb123-121"><a href="#cb123-121" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-122"><a href="#cb123-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-123"><a href="#cb123-123" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Lexer<span class="op">::</span>Position pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-124"><a href="#cb123-124" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;(line: &quot;</span> <span class="op">&lt;&lt;</span> pos<span class="op">.</span>line <span class="op">&lt;&lt;</span> <span class="st">&quot;, column:&quot;</span> <span class="op">&lt;&lt;</span> pos<span class="op">.</span>column <span class="op">&lt;&lt;</span> <span class="st">&quot;)&quot;</span><span class="op">;</span></span>
<span id="cb123-125"><a href="#cb123-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb123-126"><a href="#cb123-126" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="lexer.hpp-3">lexer.hpp</h2>
<div class="sourceCode" id="cb124"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_20_LEXER_HPP</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_20_LEXER_HPP</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Lexer <span class="op">{</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> Lexer<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> is<span class="op">);</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>    Lexer<span class="op">(</span>Lexer <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a>    Token extract<span class="op">();</span></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Position <span class="op">{</span></span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> line<span class="op">,</span> column<span class="op">;</span></span>
<span id="cb124-17"><a href="#cb124-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb124-18"><a href="#cb124-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-19"><a href="#cb124-19" aria-hidden="true" tabindex="-1"></a>    Position get_position<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb124-20"><a href="#cb124-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-21"><a href="#cb124-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb124-22"><a href="#cb124-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-23"><a href="#cb124-23" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb124-24"><a href="#cb124-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>istream<span class="op">&amp;</span> input_stream<span class="op">;</span></span>
<span id="cb124-25"><a href="#cb124-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-26"><a href="#cb124-26" aria-hidden="true" tabindex="-1"></a>    Position current_position<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb124-27"><a href="#cb124-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-28"><a href="#cb124-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> peek<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb124-29"><a href="#cb124-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-30"><a href="#cb124-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> ignore<span class="op">();</span></span>
<span id="cb124-31"><a href="#cb124-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-32"><a href="#cb124-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> get<span class="op">(</span><span class="dt">char</span><span class="op">&amp;</span> c<span class="op">);</span></span>
<span id="cb124-33"><a href="#cb124-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-34"><a href="#cb124-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> ignore_whitespace<span class="op">();</span></span>
<span id="cb124-35"><a href="#cb124-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-36"><a href="#cb124-36" aria-hidden="true" tabindex="-1"></a>    Token lex_name<span class="op">();</span></span>
<span id="cb124-37"><a href="#cb124-37" aria-hidden="true" tabindex="-1"></a>    Token lex_number<span class="op">();</span></span>
<span id="cb124-38"><a href="#cb124-38" aria-hidden="true" tabindex="-1"></a>    Token lex_operator<span class="op">();</span></span>
<span id="cb124-39"><a href="#cb124-39" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb124-40"><a href="#cb124-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-41"><a href="#cb124-41" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!(</span>Lexer <span class="at">const</span><span class="op">&amp;</span> lex<span class="op">);</span></span>
<span id="cb124-42"><a href="#cb124-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-43"><a href="#cb124-43" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">);</span></span>
<span id="cb124-44"><a href="#cb124-44" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Lexer<span class="op">::</span>Position lhs<span class="op">,</span> Lexer<span class="op">::</span>Position rhs<span class="op">);</span></span>
<span id="cb124-45"><a href="#cb124-45" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Lexer<span class="op">::</span>Position pos<span class="op">);</span></span>
<span id="cb124-46"><a href="#cb124-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-47"><a href="#cb124-47" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="list_expr.cpp-1">list_expr.cpp</h2>
<div class="sourceCode" id="cb125"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;list_expr.hpp&quot;</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;variable_expr.hpp&quot;</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ListExpr<span class="op">::</span>add<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> expr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>    elements<span class="op">.</span>push_back<span class="op">(</span>expr<span class="op">);</span></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ListExpr<span class="op">::</span>print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a>    out <span class="op">&lt;&lt;</span> <span class="ch">&#39;(&#39;</span><span class="op">;</span></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> first <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> e <span class="op">:</span> elements<span class="op">)</span> <span class="op">{</span></span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>first<span class="op">)</span></span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true" tabindex="-1"></a>            out <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb125-19"><a href="#cb125-19" aria-hidden="true" tabindex="-1"></a>        e<span class="op">-&gt;</span>print<span class="op">(</span>out<span class="op">);</span></span>
<span id="cb125-20"><a href="#cb125-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb125-21"><a href="#cb125-21" aria-hidden="true" tabindex="-1"></a>    out <span class="op">&lt;&lt;</span> <span class="ch">&#39;)&#39;</span><span class="op">;</span></span>
<span id="cb125-22"><a href="#cb125-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb125-23"><a href="#cb125-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-24"><a href="#cb125-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ListExpr<span class="op">::</span>evaluate<span class="op">(</span>SymbolTable <span class="at">const</span><span class="op">&amp;</span> symbol_table<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb125-25"><a href="#cb125-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>elements<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb125-26"><a href="#cb125-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;evaluating empty list&quot;</span><span class="op">};</span></span>
<span id="cb125-27"><a href="#cb125-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> args<span class="op">;</span></span>
<span id="cb125-28"><a href="#cb125-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: Comment on how this works.</span></span>
<span id="cb125-29"><a href="#cb125-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>transform<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>elements<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>end<span class="op">(</span>elements<span class="op">),</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>args<span class="op">),</span> <span class="op">[&amp;](</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> expr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb125-30"><a href="#cb125-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> expr<span class="op">-&gt;</span>evaluate<span class="op">(</span>symbol_table<span class="op">);</span></span>
<span id="cb125-31"><a href="#cb125-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb125-32"><a href="#cb125-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-33"><a href="#cb125-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> function_name <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>VariableExpr<span class="op">&amp;&gt;(*</span>elements<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb125-34"><a href="#cb125-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> function <span class="op">=</span> symbol_table<span class="op">.</span>at<span class="op">(</span>function_name<span class="op">.</span>get_name<span class="op">());</span></span>
<span id="cb125-35"><a href="#cb125-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> function<span class="op">(</span>args<span class="op">);</span></span>
<span id="cb125-36"><a href="#cb125-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="list_expr.hpp-1">list_expr.hpp</h2>
<div class="sourceCode" id="cb126"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_20_LIST_EXPR_HPP</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_20_LIST_EXPR_HPP</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ListExpr <span class="op">:</span> <span class="kw">public</span> Expression <span class="op">{</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;&gt;</span> elements<span class="op">;</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> add<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> expr<span class="op">);</span></span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-16"><a href="#cb126-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> evaluate<span class="op">(</span>SymbolTable <span class="at">const</span><span class="op">&amp;</span> symbol_table<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb126-17"><a href="#cb126-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb126-18"><a href="#cb126-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-19"><a href="#cb126-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="main.cpp-20">main.cpp</h2>
<p>Suggested reading order: …</p>
<p>Now that we know how to print expressions, it’s not a big step to
evaluate arithmetic expressions and print their results. We’ll do this
by adding a second virtual member function to Expression which will
perform whatever operation we want it to and then return the result as
an int.</p>
<p>What work has to be done to evaluate an expression depends on its
form. If we have a number, we can simply return it as-is; it’s already
as evaluated as it can be. If we have a list, we want to treat it as
function application. Suppose we wanted to evaluate</p>
<p><code>(+ 1 (* 2 3))</code></p>
<p>We would like this to evaluate as 1 + (2 * 3); that is, to 7. We do
this by evaluating all but the first element of the list, and then using
the first element to decide what operation should be performed. In
pseudocode:</p>
<p><code>eval (f arg1 arg2 arg3...) == f (eval arg1) (eval arg2) (eval arg3)...</code></p>
<p>What do we do when we encounter a variable name? At the moment, our
system is too simple to handle this case, so we’ll throw an
exception.</p>
<p>Note that the first element of each list is special, in that it does
not get evaluated. Instead, we will assume that it is a variable and use
the value of that to choose what operation to perform. We’ll need a way
of mapping strings to functions.</p>
<p>[Note: std::maps were not yet covered, but this is an oversight. A
chapter will be added to the beginning to introduce them properly. The
five-minute explanation is that a map is a container which associates
keys to values. That means that an object of type std::map&lt;Key,
Value&gt; will let you look up what Value corresponds to some Key
easily. For example, we can have a map from strings to ints:</p>
<p><code>std::map&lt;std::string, int&gt; map;</code></p>
<p><code>map["hello"] = 5; // automatically creates a "hello" element</code></p>
<p><code>std::cout &lt;&lt; map["hello"] &lt;&lt; '\n'; // prints 5</code></p>
<p>If the element is not yet in the map, it will be constructed and
initialized. That means that for class types the constructor will be
run, and for built-in types they will get their corresponding zero
value.]</p>
<p>We don’t want to restrict the number of elements in the list, so our
functions should take a vector of arguments. We’re only working on ints
at the moment, so the function will look as follows:</p>
<p><code>int builtin_add(std::vector&lt;int&gt; const&amp; args);</code></p>
<p>The type of the above is int(std::vector&lt;int&gt; const&amp;). The
C++ standard library provides the std::function template which we can
use to store anything that can be used like a function with a certain
type. This means we can represent each of our operations as an object of
type</p>
<p><code>std::function&lt;int(std::vector&lt;int&gt; const&amp;)&gt;</code></p>
<p>We can then represent the whole symbol table as an object of type</p>
<p><code>std::map&lt;std::string, std::function&lt;int(std::vector&lt;int&gt; const&amp;)&gt;&gt;</code></p>
<p>A bit of a mouthful, but this structure will come in useful often in
the future.</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parser.hpp&quot;</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;builtin_operations.hpp&quot;</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;symbol_table.hpp&quot;</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;map&gt;</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> symbol_table <span class="op">=</span> get_default_symbol_table<span class="op">();</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string line<span class="op">;</span></span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>getline<span class="op">(</span><span class="bu">std::</span>cin<span class="op">,</span> line<span class="op">))</span> <span class="op">{</span></span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>istringstream line_stream<span class="op">(</span>line<span class="op">);</span></span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb127-18"><a href="#cb127-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> ptr <span class="op">=</span> parse_expression<span class="op">(</span>line_stream<span class="op">);</span></span>
<span id="cb127-19"><a href="#cb127-19" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> ptr<span class="op">-&gt;</span>evaluate<span class="op">(</span>symbol_table<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb127-20"><a href="#cb127-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb127-21"><a href="#cb127-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb127-22"><a href="#cb127-22" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb127-23"><a href="#cb127-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb127-24"><a href="#cb127-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb127-25"><a href="#cb127-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb127-26"><a href="#cb127-26" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb127-27"><a href="#cb127-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Error: &quot;</span> <span class="op">&lt;&lt;</span> e<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb127-28"><a href="#cb127-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb127-29"><a href="#cb127-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb127-30"><a href="#cb127-30" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb127-31"><a href="#cb127-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Unknown error.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb127-32"><a href="#cb127-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb127-33"><a href="#cb127-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="number_expr.cpp-1">number_expr.cpp</h2>
<div class="sourceCode" id="cb128"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;number_expr.hpp&quot;</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>NumberExpr<span class="op">::</span>NumberExpr<span class="op">(</span><span class="dt">int</span> value<span class="op">)</span> <span class="op">:</span> value<span class="op">(</span>value<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> NumberExpr<span class="op">::</span>print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>    out <span class="op">&lt;&lt;</span> value<span class="op">;</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> NumberExpr<span class="op">::</span>evaluate<span class="op">(</span>SymbolTable <span class="at">const</span><span class="op">&amp;)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value<span class="op">;</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="number_expr.hpp-1">number_expr.hpp</h2>
<div class="sourceCode" id="cb129"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_20_NUMBER_EXPR_HPP</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_20_NUMBER_EXPR_HPP</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NumberExpr <span class="op">:</span> <span class="kw">public</span> Expression <span class="op">{</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value<span class="op">;</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a>    NumberExpr<span class="op">(</span><span class="dt">int</span> value<span class="op">);</span></span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> evaluate<span class="op">(</span>SymbolTable <span class="at">const</span><span class="op">&amp;</span> symbol_table<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb129-16"><a href="#cb129-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-17"><a href="#cb129-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="parser.cpp-2">parser.cpp</h2>
<div class="sourceCode" id="cb130"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;parser.hpp&quot;</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;lexer.hpp&quot;</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;number_expr.hpp&quot;</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;variable_expr.hpp&quot;</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;list_expr.hpp&quot;</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> p_expression<span class="op">(</span>Lexer<span class="op">&amp;</span> lexer<span class="op">);</span></span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> parse_expression<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> input<span class="op">)</span> <span class="op">{</span></span>
<span id="cb130-15"><a href="#cb130-15" aria-hidden="true" tabindex="-1"></a>    Lexer lexer<span class="op">(</span>input<span class="op">);</span></span>
<span id="cb130-16"><a href="#cb130-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-17"><a href="#cb130-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>lexer<span class="op">)</span></span>
<span id="cb130-18"><a href="#cb130-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: stream not in good state.&quot;</span><span class="op">};</span></span>
<span id="cb130-19"><a href="#cb130-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-20"><a href="#cb130-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> expr <span class="op">=</span> p_expression<span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb130-21"><a href="#cb130-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>expr<span class="op">)</span></span>
<span id="cb130-22"><a href="#cb130-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: no expression found.&quot;</span><span class="op">};</span></span>
<span id="cb130-23"><a href="#cb130-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-24"><a href="#cb130-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> expr<span class="op">;</span></span>
<span id="cb130-25"><a href="#cb130-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb130-26"><a href="#cb130-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-27"><a href="#cb130-27" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> p_function_call<span class="op">(</span>Lexer<span class="op">&amp;</span> lexer<span class="op">)</span> <span class="op">{</span></span>
<span id="cb130-28"><a href="#cb130-28" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb130-29"><a href="#cb130-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-30"><a href="#cb130-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> list <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>ListExpr<span class="op">&gt;();</span></span>
<span id="cb130-31"><a href="#cb130-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-32"><a href="#cb130-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">auto</span> ptr <span class="op">=</span> p_expression<span class="op">(</span>lexer<span class="op">))</span></span>
<span id="cb130-33"><a href="#cb130-33" aria-hidden="true" tabindex="-1"></a>        list<span class="op">-&gt;</span>add<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb130-34"><a href="#cb130-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-35"><a href="#cb130-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> list<span class="op">;</span></span>
<span id="cb130-36"><a href="#cb130-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb130-37"><a href="#cb130-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-38"><a href="#cb130-38" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> p_expression<span class="op">(</span>Lexer<span class="op">&amp;</span> lexer<span class="op">)</span> <span class="op">{</span></span>
<span id="cb130-39"><a href="#cb130-39" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb130-40"><a href="#cb130-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-41"><a href="#cb130-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> token <span class="op">=</span> lexer<span class="op">.</span>extract<span class="op">();</span></span>
<span id="cb130-42"><a href="#cb130-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-43"><a href="#cb130-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> end_of_file_token<span class="op">)</span></span>
<span id="cb130-44"><a href="#cb130-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;Invalid input: expected an expression.&quot;</span><span class="op">};</span></span>
<span id="cb130-45"><a href="#cb130-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-46"><a href="#cb130-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> close_paren_token<span class="op">)</span></span>
<span id="cb130-47"><a href="#cb130-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb130-48"><a href="#cb130-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-49"><a href="#cb130-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> name_token<span class="op">)</span></span>
<span id="cb130-50"><a href="#cb130-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>VariableExpr<span class="op">&gt;(</span>token<span class="op">.</span>value<span class="op">);</span></span>
<span id="cb130-51"><a href="#cb130-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> number_token<span class="op">)</span></span>
<span id="cb130-52"><a href="#cb130-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>NumberExpr<span class="op">&gt;(</span><span class="bu">std::</span>stoi<span class="op">(</span>token<span class="op">.</span>value<span class="op">));</span></span>
<span id="cb130-53"><a href="#cb130-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> open_paren_token<span class="op">)</span></span>
<span id="cb130-54"><a href="#cb130-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p_function_call<span class="op">(</span>lexer<span class="op">);</span></span>
<span id="cb130-55"><a href="#cb130-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-56"><a href="#cb130-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">{</span><span class="st">&quot;Unrecognised token type.&quot;</span><span class="op">};</span></span>
<span id="cb130-57"><a href="#cb130-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="parser.hpp-2">parser.hpp</h2>
<div class="sourceCode" id="cb131"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_20_PARSER_HPP</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_20_PARSER_HPP</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;istream&gt;</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Expression<span class="op">&gt;</span> parse_expression<span class="op">(</span><span class="bu">std::</span>istream<span class="op">&amp;</span> input<span class="op">);</span></span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="symbol_table.cpp">symbol_table.cpp</h2>
<div class="sourceCode" id="cb132"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;symbol_table.hpp&quot;</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;builtin_operations.hpp&quot;</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>SymbolTable get_default_symbol_table<span class="op">()</span> <span class="op">{</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="st">&quot;+&quot;</span><span class="op">,</span> builtin_add<span class="op">},</span></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="st">&quot;-&quot;</span><span class="op">,</span> builtin_subtract<span class="op">},</span></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="st">&quot;*&quot;</span><span class="op">,</span> builtin_multiply<span class="op">},</span></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="st">&quot;/&quot;</span><span class="op">,</span> builtin_divide<span class="op">}</span></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="symbol_table.hpp">symbol_table.hpp</h2>
<div class="sourceCode" id="cb133"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_20_SYMBOL_TABLE_HPP</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_20_SYMBOL_TABLE_HPP</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;map&gt;</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Operation <span class="op">=</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">int</span><span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;)&gt;;</span></span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> SymbolTable <span class="op">=</span> <span class="bu">std::</span>map<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> Operation<span class="op">&gt;;</span></span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a>SymbolTable get_default_symbol_table<span class="op">();</span></span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="token.cpp-4">token.cpp</h2>
<div class="sourceCode" id="cb134"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;token.hpp&quot;</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lhs<span class="op">.</span>type <span class="op">==</span> rhs<span class="op">.</span>type <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value <span class="op">==</span> rhs<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">)</span> <span class="op">{</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;{ &quot;</span><span class="op">;</span></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> open_paren_token<span class="op">)</span></span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;open_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> close_paren_token<span class="op">)</span></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;close_paren_token&quot;</span><span class="op">;</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> name_token<span class="op">)</span></span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;name_token&quot;</span><span class="op">;</span></span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> number_token<span class="op">)</span></span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;number_token&quot;</span><span class="op">;</span></span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>tok<span class="op">.</span>type <span class="op">==</span> end_of_file_token<span class="op">)</span></span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> <span class="st">&quot;end_of_file_token&quot;</span><span class="op">;</span></span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a>    os <span class="op">&lt;&lt;</span> <span class="st">&quot;, </span><span class="sc">\&quot;</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> tok<span class="op">.</span>value <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span><span class="op">;</span></span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb134-27"><a href="#cb134-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="token.hpp-5">token.hpp</h2>
<div class="sourceCode" id="cb135"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_20_TOKEN_HPP</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_20_TOKEN_HPP</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ostream&gt;</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> open_paren_token <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> close_paren_token <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> name_token <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> number_token <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> end_of_file_token <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb135-14"><a href="#cb135-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> type<span class="op">;</span></span>
<span id="cb135-15"><a href="#cb135-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string value<span class="op">;</span></span>
<span id="cb135-16"><a href="#cb135-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb135-17"><a href="#cb135-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-18"><a href="#cb135-18" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb135-19"><a href="#cb135-19" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Token <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">);</span></span>
<span id="cb135-20"><a href="#cb135-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Token <span class="at">const</span><span class="op">&amp;</span> tok<span class="op">);</span></span>
<span id="cb135-21"><a href="#cb135-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-22"><a href="#cb135-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 id="variable_expr.cpp-1">variable_expr.cpp</h2>
<div class="sourceCode" id="cb136"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;variable_expr.hpp&quot;</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>VariableExpr<span class="op">::</span>VariableExpr<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> name<span class="op">)</span> <span class="op">:</span> name<span class="op">(</span>name<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> VariableExpr<span class="op">::</span>print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>    out <span class="op">&lt;&lt;</span> name<span class="op">;</span></span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> VariableExpr<span class="op">::</span>evaluate<span class="op">(</span>SymbolTable <span class="at">const</span><span class="op">&amp;)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;variables are not yet supported&quot;</span><span class="op">};</span></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-14"><a href="#cb136-14" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string VariableExpr<span class="op">::</span>get_name<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb136-15"><a href="#cb136-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> name<span class="op">;</span></span>
<span id="cb136-16"><a href="#cb136-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="variable_expr.hpp-1">variable_expr.hpp</h2>
<div class="sourceCode" id="cb137"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef CHAPTER_20_VARIABLE_EXPR_HPP</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHAPTER_20_VARIABLE_EXPR_HPP</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;expression.hpp&quot;</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VariableExpr <span class="op">:</span> <span class="kw">public</span> Expression <span class="op">{</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>    VariableExpr<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> name<span class="op">);</span></span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-15"><a href="#cb137-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> evaluate<span class="op">(</span>SymbolTable <span class="at">const</span><span class="op">&amp;</span> symbol_table<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb137-16"><a href="#cb137-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-17"><a href="#cb137-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string get_name<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb137-18"><a href="#cb137-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb137-19"><a href="#cb137-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-20"><a href="#cb137-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 id="cpp_2_markdown.py">cpp_2_markdown.py</h1>

</body>
</html>
