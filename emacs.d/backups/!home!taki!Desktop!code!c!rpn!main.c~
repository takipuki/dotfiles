#include <stdio.h>
#include <math.h>

#define BRANDING \
"\n\
████████╗░█████╗░░█████╗░██╗░░░░░░█████╗░\n\
╚══██╔══╝██╔══██╗██╔══██╗██║░░░░░██╔══██╗\n\
░░░██║░░░██║░░╚═╝███████║██║░░░░░██║░░╚═╝\n\
░░░██║░░░██║░░██╗██╔══██║██║░░░░░██║░░██╗\n\
░░░██║░░░╚█████╔╝██║░░██║███████╗╚█████╔╝\n\
░░░╚═╝░░░░╚════╝░╚═╝░░╚═╝╚══════╝░╚════╝░\n\
"

#define HELP_TEXT \
"                                                                             \n\
tCALC is a stack based calculator that uses the Reverse Polish Notation.      \n\
                                                                              \n\
Supported unary operators: ~ c d f                                            \n\
    [~]                 negate                                                \n\
    [c]eil              round up to the nearest integer                       \n\
    [d]elete            deletes the most recent input from the stack          \n\
    [f]loor             round down to the nearest integer                     \n\
                                                                              \n\
Supported binary operators: + - * / ^ s                                       \n\
    [+]                 add                                                   \n\
    [-]                 substract                                             \n\
    [*]                 multiply                                              \n\
    [/]                 divide                                                \n\
    [^]                 exponent                                              \n\
    [s]wap              swap inputs                                           \n\
                                                                              \n\
Miscellaneous:                                                                \n\
    [a]ccumulate        reduce the stack with an operator (supports + - *)    \n\
                        [1, 2, 3] reduced with + will give (1 + (2 + 3)) = 6  \n\
                        [6, 2, 4] reduced with * will give (6 * (2 * 4)) = 48 \n\
    [q]uit              quit the program                                      \n\
    [r]eset             clears the stack                                      \n\
                                                                              \n\
Tip: You can enter a series of numbers and operators on a single line.        \n\
     e.g. 3 2 + <enter> instead of 3 <enter> 2 <enter> + <enter>              \n\
"

#define STACK_SIZE 30

/**
 * reduces the array with the given operator saves the value in result
 * [1, 2, 3] reduced with + will give (1 + (2 + (0 + 3))) = 6
 */
#define accumulate(arr, size, op, result)   \
    for (int i = size-1; i >= 0; i--)       \
        result = (arr[i]) op (result);

/**
 * print a normal c array
 */
#define printarr(arr, size) for(int i = 0; i < size; i++) printf("%15f\n", arr[i]);

int main(void) {
    printf(BRANDING);
    printf("Enter `h` anytime for help.\n");

    double stack[STACK_SIZE];
    int size = 0;
    char buf[30];     // input buffer

    double in;
    char op;
    while (1) {
        putchar('\n');
        printarr(stack, size);
        printf("=> ");
        scanf("%s", buf);

        // NOTE: continue is used in switches instead of flags
        if (sscanf(buf, "%lf", &in)) {
            //printf("Inserted number\n");
            if (size >= STACK_SIZE) {
                printf("Stack full! Do some operations.\n");
                continue;
            }
            stack[size++] = in;
            //printf("size: %d\n", size);
        }
        else {
            sscanf(buf, " %c", &op);

            // nullary operations
            switch (op) {
            case 'q':
                printf("QUITING!\n");
                return 0;
            case 'h':
                printf(HELP_TEXT);
                continue;
            case 'r':
                size = 0;
                continue;
            }

            // unary and misc operations
            if (size < 1) {
                printf("Operations need at least 1 operand on the stack!\n");
                continue;
            }
            //printf("Inserted op\n");

            switch (op) {
            case 'c':
                stack[size-1] = ceil(stack[size-1]);
                continue;
            case 'f':
                stack[size-1] = floor(stack[size-1]);
                continue;
            case 'd':
                size ? size-- : 0;
                continue;
            case '~':
                stack[size-1] = -stack[size-1];
                continue;
            }
            
            // binary operations
            if (size < 2) {
                printf("Operator needs at least 2 operands on the stack or invalid operator!\n");
                continue;
            }

            double result;
            switch (op) {
            case 'a':
                printf("Insert operator (+ - * [q]uit): ");
                if (!scanf(" %c", &op)) {
                    printf("Invalid operator!\n");
                    continue;
                }

                switch (op) {
                case 'q':
                    continue;
                case '+':
                    result = 0;
                    accumulate(stack, size, +, result);
                    break;
                case '-':
                    result = 0;
                    accumulate(stack, size, -, result);
                    break;
                case '*':
                    result = 1;
                    accumulate(stack, size, *, result);
                    break;
                default:
                    printf("Invalid operator!\n");
                    continue;
                }

                stack[0] = result;
                size = 1;
                continue;
            case 's':
                double tmp = stack[size-2];
                stack[size-2] = stack[size-1];
                stack[size-1] = tmp;
                continue;
            case '+':
                result = stack[size-2] + stack[size-1];
                break;
            case '-':
                result = stack[size-2] - stack[size-1];
                break;
            case '*':
                result = stack[size-2] * stack[size-1];
                break;
            case '/':
                if (!(stack[size-1])) { // zero
                    printf("Divide by zero!\n");
                    continue;
                }
                result = stack[size-2] / stack[size-1];
                break;
            case '^':
                result = pow(stack[size-2], stack[size-1]);
                break;
            }

            stack[--size - 1] = result;
        }
    }
}
